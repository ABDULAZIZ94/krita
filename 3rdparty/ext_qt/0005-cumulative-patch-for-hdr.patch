From 6ca9249292cc29ac4169e236f0d28f50006ba3cb Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Sat, 8 Dec 2018 15:35:43 +0300
Subject: [PATCH 04/27] Implement openGL surface color space selection in Angle

WARNING: this patch actually means that the library must be build on
         the system with at least DXGI 1.4 (DirectX 12 API) present
         in SDK. Mingw64 7.3 supports that.

1) D3D11 implementation of angle now supports GL_RGB10_A2 format

2) Technically, Angle's EGL implementation now supports the following
   display extensions:
     * EGL_KHR_gl_colorspace
     * EGL_EXT_gl_colorspace_scrgb_linear
     * EGL_EXT_gl_colorspace_bt2020_pq

3) D3D11 implementation of angle now supports GL_COLOR_SPACE attribute,
   which allows selection one of four color modes:
     * Linear --- just pass-through data to GPU
     * sRGB --- p709-g22 color space. WARNING: in 8-bit mode the system
       becomes clever and automatically converts linear framebuffer
       attachments to sRGB space, as per EGL_KHR_gl_colorspace definition.
       It is not possible to select sRGB without this extra "feature".
     * scRGB --- p709-g10 color space. This mode is the only mode
       supported in f16-bit mode (and it is also not supported in other
       bit depths).
     * bt2020-pq --- p2020-pq color space. Supported only in 10-bit mode.

5) SwapChain is now created in DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL mode:
     * because non-flip mode is considered deprecated and HDR is not
       supported in it;
     * because in flip-discard mode partial updates from
       SwapChain11::present() are not supported and return an error,
       which is never checked :)

6) As a fallback, SwapChain uses old DXGI_SWAP_EFFECT_DISCARD, because
   flip modes are not available on Windows 7 and such old systems.

Notes:

eglCreatePixmapSurface() is not implemented in Angle, so the support is
not added.

eglCreatePlatformWindowSurface() and eglCreatePlatformPixmapSurface()
do not have support for color spaces according to the extension wording
(and they are also not supported by Angle :) )

Change-Id: I68204a5db6bbd7066a83a8d1d021ce76cd1cf6f6
---
 src/3rdparty/angle/src/common/platform.h      |  14 +-
 src/3rdparty/angle/src/libANGLE/Caps.cpp      |   8 +-
 src/3rdparty/angle/src/libANGLE/Caps.h        |   9 +
 .../src/libANGLE/renderer/d3d/RendererD3D.h   |   3 +-
 .../src/libANGLE/renderer/d3d/SurfaceD3D.cpp  |  26 +-
 .../src/libANGLE/renderer/d3d/SurfaceD3D.h    |   1 +
 .../renderer/d3d/d3d11/Renderer11.cpp         |  16 +-
 .../libANGLE/renderer/d3d/d3d11/Renderer11.h  |   4 +-
 .../renderer/d3d/d3d11/SwapChain11.cpp        |  91 ++-
 .../libANGLE/renderer/d3d/d3d11/SwapChain11.h |   4 +-
 .../d3d/d3d11/win32/NativeWindow11Win32.cpp   |  19 +-
 .../libANGLE/renderer/d3d/d3d9/Renderer9.cpp  |   4 +-
 .../libANGLE/renderer/d3d/d3d9/Renderer9.h    |   3 +-
 .../angle/src/libANGLE/validationEGL.cpp      |  53 ++
 ...-surface-color-space-selection-in-An.patch | 596 ++++++++++++++++++
 15 files changed, 831 insertions(+), 20 deletions(-)
 create mode 100644 src/angle/patches/0013-Implement-openGL-surface-color-space-selection-in-An.patch

diff --git a/src/3rdparty/angle/src/common/platform.h b/src/3rdparty/angle/src/common/platform.h
index fb251da5..2e179945 100644
--- a/src/3rdparty/angle/src/common/platform.h
+++ b/src/3rdparty/angle/src/common/platform.h
@@ -59,12 +59,14 @@
 #   endif
 
 #   if defined(ANGLE_ENABLE_D3D11)
-#include <d3d10_1.h>
-#include <d3d11.h>
-#include <d3d11_3.h>
-#include <d3dcompiler.h>
-#include <dxgi.h>
-#include <dxgi1_2.h>
+#       include <d3d10_1.h>
+#       include <d3d11.h>
+#       include <dxgi.h>
+#       include <d3d11_1.h>
+#       include <d3d11_3.h>
+#       include <dxgi1_2.h>
+#       include <dxgi1_4.h> // WARNING: This is actually D3D12!
+#       include <d3dcompiler.h>
 #   endif
 
 #if defined(ANGLE_ENABLE_D3D9) || defined(ANGLE_ENABLE_D3D11)
diff --git a/src/3rdparty/angle/src/libANGLE/Caps.cpp b/src/3rdparty/angle/src/libANGLE/Caps.cpp
index 44da2bbe..20884574 100644
--- a/src/3rdparty/angle/src/libANGLE/Caps.cpp
+++ b/src/3rdparty/angle/src/libANGLE/Caps.cpp
@@ -1101,7 +1101,10 @@ DisplayExtensions::DisplayExtensions()
       displayTextureShareGroup(false),
       createContextClientArrays(false),
       programCacheControl(false),
-      robustResourceInitialization(false)
+      robustResourceInitialization(false),
+      colorspaceSRGB(false),
+      colorspaceSCRGBLinear(false),
+      colorspaceBt2020PQ(false)
 {
 }
 
@@ -1146,6 +1149,9 @@ std::vector<std::string> DisplayExtensions::getStrings() const
     InsertExtensionString("EGL_ANGLE_create_context_client_arrays",              createContextClientArrays,          &extensionStrings);
     InsertExtensionString("EGL_ANGLE_program_cache_control",                     programCacheControl,                &extensionStrings);
     InsertExtensionString("EGL_ANGLE_robust_resource_initialization",            robustResourceInitialization,       &extensionStrings);
+    InsertExtensionString("EGL_KHR_gl_colorspace",                               colorspaceSRGB,                     &extensionStrings);
+    InsertExtensionString("EGL_EXT_gl_colorspace_scrgb_linear",                  colorspaceSCRGBLinear,              &extensionStrings);
+    InsertExtensionString("EGL_EXT_gl_colorspace_bt2020_pq",                     colorspaceBt2020PQ,                 &extensionStrings);
     // TODO(jmadill): Enable this when complete.
     //InsertExtensionString("KHR_create_context_no_error",                       createContextNoError,               &extensionStrings);
     // clang-format on
diff --git a/src/3rdparty/angle/src/libANGLE/Caps.h b/src/3rdparty/angle/src/libANGLE/Caps.h
index 64bdf971..8157af58 100644
--- a/src/3rdparty/angle/src/libANGLE/Caps.h
+++ b/src/3rdparty/angle/src/libANGLE/Caps.h
@@ -692,6 +692,15 @@ struct DisplayExtensions
 
     // EGL_ANGLE_robust_resource_initialization
     bool robustResourceInitialization;
+
+    // EGL_KHR_gl_colorspace
+    bool colorspaceSRGB;
+
+    // EGL_EXT_gl_colorspace_scrgb_linear
+    bool colorspaceSCRGBLinear;
+
+    // EGL_EXT_gl_colorspace_bt2020_pq
+    bool colorspaceBt2020PQ;
 };
 
 struct DeviceExtensions
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h
index dcc98f2e..b8ee6356 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h
@@ -130,7 +130,8 @@ class RendererD3D : public BufferFactoryD3D, public MultisampleTextureInitialize
                                           GLenum backBufferFormat,
                                           GLenum depthBufferFormat,
                                           EGLint orientation,
-                                          EGLint samples) = 0;
+                                          EGLint samples,
+                                          EGLint colorSpace) = 0;
     virtual egl::Error getD3DTextureInfo(const egl::Config *configuration,
                                          IUnknown *d3dTexture,
                                          EGLint *width,
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp
index 7657aef7..efd4dd1a 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp
@@ -22,6 +22,27 @@
 namespace rx
 {
 
+GLenum renderTargetFormatFromColorSpace(egl::Display *display, GLenum baseFormat, EGLint colorSpace)
+{
+    GLenum result = baseFormat;
+
+    /**
+     * If sRGB extension is supported, we should change the surface format
+     * to a specific one that does support automated gamma conversion.
+     *
+     * TODO: openGL doesn't support BGRA-sRGB texture format, so creation of
+     *       textures in this format technically is not supported!
+     */
+    if (display->getExtensions().colorspaceSRGB &&
+        baseFormat == GL_RGBA8_OES &&
+        colorSpace == EGL_GL_COLORSPACE_SRGB_KHR)
+    {
+        result = GL_SRGB8_ALPHA8;
+    }
+
+    return result;
+}
+
 SurfaceD3D::SurfaceD3D(const egl::SurfaceState &state,
                        RendererD3D *renderer,
                        egl::Display *display,
@@ -34,7 +55,8 @@ SurfaceD3D::SurfaceD3D(const egl::SurfaceState &state,
       mDisplay(display),
       mFixedSize(window == nullptr || attribs.get(EGL_FIXED_SIZE_ANGLE, EGL_FALSE) == EGL_TRUE),
       mOrientation(static_cast<EGLint>(attribs.get(EGL_SURFACE_ORIENTATION_ANGLE, 0))),
-      mRenderTargetFormat(state.config->renderTargetFormat),
+      mColorSpace(static_cast<EGLint>(attribs.get(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_LINEAR_KHR))),
+      mRenderTargetFormat(renderTargetFormatFromColorSpace(display, state.config->renderTargetFormat, mColorSpace)),
       mDepthStencilFormat(state.config->depthStencilFormat),
       mSwapChain(nullptr),
       mSwapIntervalDirty(true),
@@ -148,7 +170,7 @@ egl::Error SurfaceD3D::resetSwapChain(const egl::Display *display)
 
     mSwapChain =
         mRenderer->createSwapChain(mNativeWindow, mShareHandle, mD3DTexture, mRenderTargetFormat,
-                                   mDepthStencilFormat, mOrientation, mState.config->samples);
+                                   mDepthStencilFormat, mOrientation, mState.config->samples, mColorSpace);
     if (!mSwapChain)
     {
         return egl::EglBadAlloc();
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h
index 01d25732..ccb793d4 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h
@@ -90,6 +90,7 @@ class SurfaceD3D : public SurfaceImpl
 
     bool mFixedSize;
     GLint mOrientation;
+    EGLint mColorSpace;
 
     GLenum mRenderTargetFormat;
     GLenum mDepthStencilFormat;
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp
index b0ef9abd..f0e497b5 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp
@@ -465,6 +465,7 @@ Renderer11::Renderer11(egl::Display *display)
     mRenderer11DeviceCaps.supportsConstantBufferOffsets = false;
     mRenderer11DeviceCaps.supportsVpRtIndexWriteFromVertexShader = false;
     mRenderer11DeviceCaps.supportsDXGI1_2               = false;
+    mRenderer11DeviceCaps.supportsDXGI1_4               = false;
     mRenderer11DeviceCaps.B5G6R5support                 = 0;
     mRenderer11DeviceCaps.B4G4R4A4support               = 0;
     mRenderer11DeviceCaps.B5G5R5A1support               = 0;
@@ -918,6 +919,7 @@ egl::Error Renderer11::initializeDevice()
 
     // Gather stats on DXGI and D3D feature level
     ANGLE_HISTOGRAM_BOOLEAN("GPU.ANGLE.SupportsDXGI1_2", mRenderer11DeviceCaps.supportsDXGI1_2);
+    ANGLE_HISTOGRAM_BOOLEAN("GPU.ANGLE.SupportsDXGI1_4", mRenderer11DeviceCaps.supportsDXGI1_4);
 
     ANGLEFeatureLevel angleFeatureLevel = GetANGLEFeatureLevel(mRenderer11DeviceCaps.featureLevel);
 
@@ -1002,6 +1004,10 @@ void Renderer11::populateRenderer11DeviceCaps()
     IDXGIAdapter2 *dxgiAdapter2 = d3d11::DynamicCastComObject<IDXGIAdapter2>(mDxgiAdapter);
     mRenderer11DeviceCaps.supportsDXGI1_2 = (dxgiAdapter2 != nullptr);
     SafeRelease(dxgiAdapter2);
+
+    IDXGIAdapter3 *dxgiAdapter3 = d3d11::DynamicCastComObject<IDXGIAdapter3>(mDxgiAdapter);
+    mRenderer11DeviceCaps.supportsDXGI1_4 = (dxgiAdapter3 != nullptr);
+    SafeRelease(dxgiAdapter3);
 }
 
 gl::SupportedSampleSet Renderer11::generateSampleSetForEGLConfig(
@@ -1241,6 +1247,11 @@ void Renderer11::generateDisplayExtensions(egl::DisplayExtensions *outExtensions
 
     // All D3D feature levels support robust resource init
     outExtensions->robustResourceInitialization = true;
+
+    // color space selection supported in DXGI 1.4 only
+    outExtensions->colorspaceSRGB = mRenderer11DeviceCaps.supportsDXGI1_4;
+    outExtensions->colorspaceSCRGBLinear = mRenderer11DeviceCaps.supportsDXGI1_4;
+    outExtensions->colorspaceBt2020PQ = mRenderer11DeviceCaps.supportsDXGI1_4;
 }
 
 gl::Error Renderer11::flush()
@@ -1436,10 +1447,11 @@ SwapChainD3D *Renderer11::createSwapChain(NativeWindowD3D *nativeWindow,
                                           GLenum backBufferFormat,
                                           GLenum depthBufferFormat,
                                           EGLint orientation,
-                                          EGLint samples)
+                                          EGLint samples,
+                                          EGLint colorSpace)
 {
     return new SwapChain11(this, GetAs<NativeWindow11>(nativeWindow), shareHandle, d3dTexture,
-                           backBufferFormat, depthBufferFormat, orientation, samples);
+                           backBufferFormat, depthBufferFormat, orientation, samples, colorSpace);
 }
 
 void *Renderer11::getD3DDevice()
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h
index a8c24e68..3516bf77 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h
@@ -49,6 +49,7 @@ struct Renderer11DeviceCaps
 
     D3D_FEATURE_LEVEL featureLevel;
     bool supportsDXGI1_2;                // Support for DXGI 1.2
+    bool supportsDXGI1_4;               // Support for DXGI 1.4
     bool supportsClearView;              // Support for ID3D11DeviceContext1::ClearView
     bool supportsConstantBufferOffsets;  // Support for Constant buffer offset
     bool supportsVpRtIndexWriteFromVertexShader;  // VP/RT can be selected in the Vertex Shader
@@ -138,7 +139,8 @@ class Renderer11 : public RendererD3D
                                   GLenum backBufferFormat,
                                   GLenum depthBufferFormat,
                                   EGLint orientation,
-                                  EGLint samples) override;
+                                  EGLint samples,
+                                  EGLint colorSpace) override;
     egl::Error getD3DTextureInfo(const egl::Config *configuration,
                                  IUnknown *d3dTexture,
                                  EGLint *width,
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp
index dcfd0648..fc967b90 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp
@@ -18,6 +18,11 @@
 #include "libANGLE/renderer/d3d/d3d11/texture_format_table.h"
 #include "third_party/trace_event/trace_event.h"
 
+#if 0
+// used only for HDR metadata configuration options
+#include <dxgi1_5.h>
+#endif
+
 // Precompiled shaders
 #include "libANGLE/renderer/d3d/d3d11/shaders/compiled/passthrough2d11vs.h"
 #include "libANGLE/renderer/d3d/d3d11/shaders/compiled/passthroughrgba2d11ps.h"
@@ -56,12 +61,14 @@ SwapChain11::SwapChain11(Renderer11 *renderer,
                          GLenum backBufferFormat,
                          GLenum depthBufferFormat,
                          EGLint orientation,
-                         EGLint samples)
+                         EGLint samples,
+                         EGLint colorSpace)
     : SwapChainD3D(shareHandle, d3dTexture, backBufferFormat, depthBufferFormat),
       mRenderer(renderer),
       mWidth(-1),
       mHeight(-1),
       mOrientation(orientation),
+      mColorSpace(colorSpace),
       mAppCreatedShareHandle(mShareHandle != nullptr),
       mSwapInterval(0),
       mPassThroughResourcesInit(false),
@@ -620,10 +627,92 @@ EGLint SwapChain11::reset(const gl::Context *context,
             mSwapChain1 = d3d11::DynamicCastComObject<IDXGISwapChain1>(mSwapChain);
         }
 
+        if (mRenderer->getRenderer11DeviceCaps().supportsDXGI1_4)
+        {
+            IDXGISwapChain3 *swapChain3 = d3d11::DynamicCastComObject<IDXGISwapChain3>(mSwapChain);
+
+            printf("*** EGL colorSpace: 0x%X\n", mColorSpace);
+            printf("*** EGL format: 0x%X\n", mOffscreenRenderTargetFormat);
+            printf("*** Native format: 0x%X\n", getSwapChainNativeFormat());
+
+            if (mColorSpace != EGL_GL_COLORSPACE_LINEAR_KHR) {
+                DXGI_COLOR_SPACE_TYPE nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
+                switch (mColorSpace)
+                {
+                case EGL_GL_COLORSPACE_SRGB_KHR:
+                    nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
+                    break;
+                case EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT:
+                    nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                    break;
+                case EGL_GL_COLORSPACE_BT2020_PQ_EXT:
+                    nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                    break;
+                default:
+                    ASSERT(0 && "Unsupported colorspace requested");
+                }
+
+                printf("*** Native colorSpace: 0x%X\n", nativeColorSpace);
+
+                UINT supported = 0;
+                result = swapChain3->CheckColorSpaceSupport(nativeColorSpace, &supported);
+                ASSERT(SUCCEEDED(result));
+                if (!(supported & DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT)) {
+                    SafeRelease(swapChain3);
+                    return EGL_BAD_MATCH;
+                }
+
+                result = swapChain3->SetColorSpace1(nativeColorSpace);
+                ASSERT(SUCCEEDED(result));
+            }
+
+            SafeRelease(swapChain3);
+
+#if 0
+
+            IDXGISwapChain4 *swapChain4 = d3d11::DynamicCastComObject<IDXGISwapChain4>(mSwapChain);
+
+            DXGI_HDR_METADATA_HDR10 md;
+            md.RedPrimary[0] = 0.680 * 50000;
+            md.RedPrimary[1] = 0.320 * 50000;
+            md.GreenPrimary[0] = 0.265 * 50000;
+            md.GreenPrimary[1] = 0.690 * 50000;
+            md.BluePrimary[0] = 0.150 * 50000;
+            md.BluePrimary[1] = 0.060 * 50000;
+            md.WhitePoint[0] = 0.3127 * 50000;
+            md.WhitePoint[1] = 0.3290 * 50000;
+            md.MaxMasteringLuminance = 1000 * 10000;
+            md.MinMasteringLuminance = 0.001 * 10000;
+            md.MaxContentLightLevel = 1000;
+            md.MaxFrameAverageLightLevel = 200;
+            result = swapChain4->SetHDRMetaData(DXGI_HDR_METADATA_TYPE_HDR10, sizeof(md), &md);
+            printf("*** Result hdr 0x%X\n", result);
+            SafeRelease(swapChain4);
+#endif
+        }
+
         ID3D11Texture2D *backbufferTex = nullptr;
         result                         = mSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D),
                                        reinterpret_cast<LPVOID *>(&backbufferTex));
         ASSERT(SUCCEEDED(result));
+
+        // TODO: recover rendering to sRGB
+        //
+        // D3D11_RENDER_TARGET_VIEW_DESC offscreenRTVDesc;
+        // offscreenRTVDesc.Format = getSwapChainNativeFormat();
+        //
+        // if (mColorSpace == EGL_GL_COLORSPACE_SRGB_KHR) {
+        //     if (offscreenRTVDesc.Format == DXGI_FORMAT_R8G8B8A8_UNORM) {
+        //         offscreenRTVDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
+        //     }
+        //
+        //     if (offscreenRTVDesc.Format == DXGI_FORMAT_B8G8R8A8_UNORM) {
+        //         offscreenRTVDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;
+        //     }
+        // }
+        //
+        // printf("*** Render target format: 0x%X\n", offscreenRTVDesc.Format);
+
         const auto &format =
             d3d11::Format::Get(mOffscreenRenderTargetFormat, mRenderer->getRenderer11DeviceCaps());
         mBackBufferTexture.set(backbufferTex, format);
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h
index eca06821..2a4b9ba2 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h
@@ -28,7 +28,8 @@ class SwapChain11 final : public SwapChainD3D
                 GLenum backBufferFormat,
                 GLenum depthBufferFormat,
                 EGLint orientation,
-                EGLint samples);
+                EGLint samples,
+                EGLint colorSpace);
     ~SwapChain11() override;
 
     EGLint resize(const gl::Context *context,
@@ -93,6 +94,7 @@ class SwapChain11 final : public SwapChainD3D
     EGLint mWidth;
     EGLint mHeight;
     const EGLint mOrientation;
+    EGLint mColorSpace;
     bool mAppCreatedShareHandle;
     unsigned int mSwapInterval;
     bool mPassThroughResourcesInit;
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp
index 5394e3d3..af52c41d 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp
@@ -146,6 +146,9 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
 
     // Use IDXGIFactory2::CreateSwapChainForHwnd if DXGI 1.2 is available to create a
     // DXGI_SWAP_EFFECT_SEQUENTIAL swap chain.
+    //
+    // NOTE: in non-flip mode HDR rendering is not supported, so use it
+    //       by default
     IDXGIFactory2 *factory2 = d3d11::DynamicCastComObject<IDXGIFactory2>(factory);
     if (factory2 != nullptr)
     {
@@ -158,9 +161,9 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
         swapChainDesc.SampleDesc.Quality    = 0;
         swapChainDesc.BufferUsage =
             DXGI_USAGE_RENDER_TARGET_OUTPUT | DXGI_USAGE_SHADER_INPUT | DXGI_USAGE_BACK_BUFFER;
-        swapChainDesc.BufferCount   = 1;
+        swapChainDesc.BufferCount   = 2;
         swapChainDesc.Scaling       = DXGI_SCALING_STRETCH;
-        swapChainDesc.SwapEffect    = DXGI_SWAP_EFFECT_SEQUENTIAL;
+        swapChainDesc.SwapEffect    = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
         swapChainDesc.AlphaMode     = DXGI_ALPHA_MODE_UNSPECIFIED;
         swapChainDesc.Flags         = 0;
         IDXGISwapChain1 *swapChain1 = nullptr;
@@ -176,7 +179,7 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
     }
 
     DXGI_SWAP_CHAIN_DESC swapChainDesc               = {};
-    swapChainDesc.BufferCount                        = 1;
+    swapChainDesc.BufferCount                        = 2;
     swapChainDesc.BufferDesc.Format                  = format;
     swapChainDesc.BufferDesc.Width                   = width;
     swapChainDesc.BufferDesc.Height                  = height;
@@ -191,6 +194,16 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
     swapChainDesc.SampleDesc.Count   = samples;
     swapChainDesc.SampleDesc.Quality = 0;
     swapChainDesc.Windowed           = TRUE;
+
+    /**
+     * NOTE1: in discard mode the swap chain doesn't support partial
+     *        presentatiopn with Present1() call. Though it is not a big
+     *        problem, because in case DXGI 1.2 is supported this code is
+     *        unreachable.
+     *
+     * NOTE2: Flip modes are not supported on Windows 7 and the like,
+     *        so use a legacy mode as a fallback
+     */
     swapChainDesc.SwapEffect         = DXGI_SWAP_EFFECT_DISCARD;
 
     HRESULT result = factory->CreateSwapChain(device, &swapChainDesc, swapChain);
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
index 75c62988..58596169 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
@@ -718,8 +718,10 @@ SwapChainD3D *Renderer9::createSwapChain(NativeWindowD3D *nativeWindow,
                                          GLenum backBufferFormat,
                                          GLenum depthBufferFormat,
                                          EGLint orientation,
-                                         EGLint samples)
+                                         EGLint samples,
+                                         EGLint colorSpace)
 {
+    UNUSED_VARIABLE(colorSpace);
     return new SwapChain9(this, GetAs<NativeWindow9>(nativeWindow), shareHandle, d3dTexture,
                           backBufferFormat, depthBufferFormat, orientation);
 }
diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h
index 9ddee45f..ce4bb201 100644
--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h
+++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h
@@ -92,7 +92,8 @@ class Renderer9 : public RendererD3D
                                   GLenum backBufferFormat,
                                   GLenum depthBufferFormat,
                                   EGLint orientation,
-                                  EGLint samples) override;
+                                  EGLint samples,
+                                  EGLint colorSpace) override;
     egl::Error getD3DTextureInfo(const egl::Config *configuration,
                                  IUnknown *d3dTexture,
                                  EGLint *width,
diff --git a/src/3rdparty/angle/src/libANGLE/validationEGL.cpp b/src/3rdparty/angle/src/libANGLE/validationEGL.cpp
index 13a3a9e2..858d7ee9 100644
--- a/src/3rdparty/angle/src/libANGLE/validationEGL.cpp
+++ b/src/3rdparty/angle/src/libANGLE/validationEGL.cpp
@@ -885,6 +885,32 @@ Error ValidateCreateWindowSurface(Display *display, Config *config, EGLNativeWin
                                               "either EGL_TRUE or EGL_FALSE.";
               }
               break;
+          case EGL_GL_COLORSPACE:
+
+              if (!displayExtensions.colorspaceSRGB)
+              {
+                  return EglBadAttribute() << "EGL_KHR_gl_colorspace is not supported on this platform.";
+              }
+
+              if (value == EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT)
+              {
+                  if (!displayExtensions.colorspaceSCRGBLinear)
+                  {
+                      return EglBadAttribute() << "EGL_EXT_gl_colorspace_scrgb_linear is not supported on this platform.";
+                  }
+              }
+              else if (value == EGL_GL_COLORSPACE_BT2020_PQ_EXT)
+              {
+                  if (!displayExtensions.colorspaceBt2020PQ)
+                  {
+                      return EglBadAttribute() << "EGL_EXT_gl_colorspace_bt2020_pq is not supported on this platform.";
+                  }
+              }
+              else if (value != EGL_GL_COLORSPACE_SRGB_KHR && value != EGL_GL_COLORSPACE_LINEAR_KHR)
+              {
+                  return EglBadAttribute() << "Unknown EGL color space requested";
+              }
+              break;
 
           default:
               return EglBadAttribute();
@@ -977,6 +1003,33 @@ Error ValidateCreatePbufferSurface(Display *display, Config *config, const Attri
               }
               break;
 
+        case EGL_GL_COLORSPACE:
+
+            if (!displayExtensions.colorspaceSRGB)
+            {
+                return EglBadAttribute() << "EGL_KHR_gl_colorspace is not supported on this platform.";
+            }
+
+            if (value == EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT)
+            {
+                if (!displayExtensions.colorspaceSCRGBLinear)
+                {
+                    return EglBadAttribute() << "EGL_EXT_gl_colorspace_scrgb_linear is not supported on this platform.";
+                }
+            }
+            else if (value == EGL_GL_COLORSPACE_BT2020_PQ_EXT)
+            {
+                if (!displayExtensions.colorspaceBt2020PQ)
+                {
+                    return EglBadAttribute() << "EGL_EXT_gl_colorspace_bt2020_pq is not supported on this platform.";
+                }
+            }
+            else if (value != EGL_GL_COLORSPACE_SRGB_KHR && value != EGL_GL_COLORSPACE_LINEAR_KHR)
+            {
+                return EglBadAttribute() << "Unknown EGL color space requested";
+            }
+            break;
+
           default:
               return EglBadAttribute();
         }
diff --git a/src/angle/patches/0013-Implement-openGL-surface-color-space-selection-in-An.patch b/src/angle/patches/0013-Implement-openGL-surface-color-space-selection-in-An.patch
new file mode 100644
index 00000000..dfbe3626
--- /dev/null
+++ b/src/angle/patches/0013-Implement-openGL-surface-color-space-selection-in-An.patch
@@ -0,0 +1,596 @@
+From 05082a2affad3428e2ba4475a5c083e81a7730ab Mon Sep 17 00:00:00 2001
+From: Dmitry Kazakov <dimula73@gmail.com>
+Date: Sat, 8 Dec 2018 15:35:43 +0300
+Subject: [PATCH] Implement openGL surface color space selection in Angle
+
+WARNING: this patch actually means that the library must be build on
+         the system with at least DXGI 1.4 (DirectX 12 API) present
+         in SDK. Mingw64 7.3 supports that.
+
+1) D3D11 implementation of angle now supports GL_RGB10_A2 format
+
+2) Technically, Angle's EGL implementation now supports the following
+   display extensions:
+     * EGL_KHR_gl_colorspace
+     * EGL_EXT_gl_colorspace_scrgb_linear
+     * EGL_EXT_gl_colorspace_bt2020_pq
+
+3) D3D11 implementation of angle now supports GL_COLOR_SPACE attribute,
+   which allows selection one of four color modes:
+     * Linear --- just pass-through data to GPU
+     * sRGB --- p709-g22 color space. WARNING: in 8-bit mode the system
+       becomes clever and automatically converts linear framebuffer
+       attachments to sRGB space, as per EGL_KHR_gl_colorspace definition.
+       It is not possible to select sRGB without this extra "feature".
+     * scRGB --- p709-g10 color space. This mode is the only mode
+       supported in f16-bit mode (and it is also not supported in other
+       bit depths).
+     * bt2020-pq --- p2020-pq color space. Supported only in 10-bit mode.
+
+5) SwapChain is now created in DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL mode:
+     * because non-flip mode is considered deprecated and HDR is not
+       supported in it;
+     * because in flip-discard mode partial updates from
+       SwapChain11::present() are not supported and return an error,
+       which is never checked :)
+
+6) As a fallback, SwapChain uses old DXGI_SWAP_EFFECT_DISCARD, because
+   flip modes are not available on Windows 7 and such old systems.
+
+Notes:
+
+eglCreatePixmapSurface() is not implemented in Angle, so the support is
+not added.
+
+eglCreatePlatformWindowSurface() and eglCreatePlatformPixmapSurface()
+do not have support for color spaces according to the extension wording
+(and they are also not supported by Angle :) )
+
+Change-Id: I68204a5db6bbd7066a83a8d1d021ce76cd1cf6f6
+---
+ src/3rdparty/angle/src/common/platform.h      | 14 +--
+ src/3rdparty/angle/src/libANGLE/Caps.cpp      |  8 +-
+ src/3rdparty/angle/src/libANGLE/Caps.h        |  9 ++
+ .../src/libANGLE/renderer/d3d/RendererD3D.h   |  3 +-
+ .../src/libANGLE/renderer/d3d/SurfaceD3D.cpp  | 26 +++++-
+ .../src/libANGLE/renderer/d3d/SurfaceD3D.h    |  1 +
+ .../renderer/d3d/d3d11/Renderer11.cpp         | 16 +++-
+ .../libANGLE/renderer/d3d/d3d11/Renderer11.h  |  4 +-
+ .../renderer/d3d/d3d11/SwapChain11.cpp        | 91 ++++++++++++++++++-
+ .../libANGLE/renderer/d3d/d3d11/SwapChain11.h |  4 +-
+ .../d3d/d3d11/win32/NativeWindow11Win32.cpp   | 19 +++-
+ .../libANGLE/renderer/d3d/d3d9/Renderer9.cpp  |  4 +-
+ .../libANGLE/renderer/d3d/d3d9/Renderer9.h    |  3 +-
+ .../angle/src/libANGLE/validationEGL.cpp      | 53 +++++++++++
+ 14 files changed, 235 insertions(+), 20 deletions(-)
+
+diff --git a/src/3rdparty/angle/src/common/platform.h b/src/3rdparty/angle/src/common/platform.h
+index fb251da579..2e17994557 100644
+--- a/src/3rdparty/angle/src/common/platform.h
++++ b/src/3rdparty/angle/src/common/platform.h
+@@ -59,12 +59,14 @@
+ #   endif
+ 
+ #   if defined(ANGLE_ENABLE_D3D11)
+-#include <d3d10_1.h>
+-#include <d3d11.h>
+-#include <d3d11_3.h>
+-#include <d3dcompiler.h>
+-#include <dxgi.h>
+-#include <dxgi1_2.h>
++#       include <d3d10_1.h>
++#       include <d3d11.h>
++#       include <dxgi.h>
++#       include <d3d11_1.h>
++#       include <d3d11_3.h>
++#       include <dxgi1_2.h>
++#       include <dxgi1_4.h> // WARNING: This is actually D3D12!
++#       include <d3dcompiler.h>
+ #   endif
+ 
+ #if defined(ANGLE_ENABLE_D3D9) || defined(ANGLE_ENABLE_D3D11)
+diff --git a/src/3rdparty/angle/src/libANGLE/Caps.cpp b/src/3rdparty/angle/src/libANGLE/Caps.cpp
+index 44da2bbe27..2088457458 100644
+--- a/src/3rdparty/angle/src/libANGLE/Caps.cpp
++++ b/src/3rdparty/angle/src/libANGLE/Caps.cpp
+@@ -1101,7 +1101,10 @@ DisplayExtensions::DisplayExtensions()
+       displayTextureShareGroup(false),
+       createContextClientArrays(false),
+       programCacheControl(false),
+-      robustResourceInitialization(false)
++      robustResourceInitialization(false),
++      colorspaceSRGB(false),
++      colorspaceSCRGBLinear(false),
++      colorspaceBt2020PQ(false)
+ {
+ }
+ 
+@@ -1146,6 +1149,9 @@ std::vector<std::string> DisplayExtensions::getStrings() const
+     InsertExtensionString("EGL_ANGLE_create_context_client_arrays",              createContextClientArrays,          &extensionStrings);
+     InsertExtensionString("EGL_ANGLE_program_cache_control",                     programCacheControl,                &extensionStrings);
+     InsertExtensionString("EGL_ANGLE_robust_resource_initialization",            robustResourceInitialization,       &extensionStrings);
++    InsertExtensionString("EGL_KHR_gl_colorspace",                               colorspaceSRGB,                     &extensionStrings);
++    InsertExtensionString("EGL_EXT_gl_colorspace_scrgb_linear",                  colorspaceSCRGBLinear,              &extensionStrings);
++    InsertExtensionString("EGL_EXT_gl_colorspace_bt2020_pq",                     colorspaceBt2020PQ,                 &extensionStrings);
+     // TODO(jmadill): Enable this when complete.
+     //InsertExtensionString("KHR_create_context_no_error",                       createContextNoError,               &extensionStrings);
+     // clang-format on
+diff --git a/src/3rdparty/angle/src/libANGLE/Caps.h b/src/3rdparty/angle/src/libANGLE/Caps.h
+index 64bdf97112..8157af5800 100644
+--- a/src/3rdparty/angle/src/libANGLE/Caps.h
++++ b/src/3rdparty/angle/src/libANGLE/Caps.h
+@@ -692,6 +692,15 @@ struct DisplayExtensions
+ 
+     // EGL_ANGLE_robust_resource_initialization
+     bool robustResourceInitialization;
++
++    // EGL_KHR_gl_colorspace
++    bool colorspaceSRGB;
++
++    // EGL_EXT_gl_colorspace_scrgb_linear
++    bool colorspaceSCRGBLinear;
++
++    // EGL_EXT_gl_colorspace_bt2020_pq
++    bool colorspaceBt2020PQ;
+ };
+ 
+ struct DeviceExtensions
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h
+index dcc98f2ec6..b8ee635625 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/RendererD3D.h
+@@ -130,7 +130,8 @@ class RendererD3D : public BufferFactoryD3D, public MultisampleTextureInitialize
+                                           GLenum backBufferFormat,
+                                           GLenum depthBufferFormat,
+                                           EGLint orientation,
+-                                          EGLint samples) = 0;
++                                          EGLint samples,
++                                          EGLint colorSpace) = 0;
+     virtual egl::Error getD3DTextureInfo(const egl::Config *configuration,
+                                          IUnknown *d3dTexture,
+                                          EGLint *width,
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp
+index 7657aef79e..efd4dd1a24 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.cpp
+@@ -22,6 +22,27 @@
+ namespace rx
+ {
+ 
++GLenum renderTargetFormatFromColorSpace(egl::Display *display, GLenum baseFormat, EGLint colorSpace)
++{
++    GLenum result = baseFormat;
++
++    /**
++     * If sRGB extension is supported, we should change the surface format
++     * to a specific one that does support automated gamma conversion.
++     *
++     * TODO: openGL doesn't support BGRA-sRGB texture format, so creation of
++     *       textures in this format technically is not supported!
++     */
++    if (display->getExtensions().colorspaceSRGB &&
++        baseFormat == GL_RGBA8_OES &&
++        colorSpace == EGL_GL_COLORSPACE_SRGB_KHR)
++    {
++        result = GL_SRGB8_ALPHA8;
++    }
++
++    return result;
++}
++
+ SurfaceD3D::SurfaceD3D(const egl::SurfaceState &state,
+                        RendererD3D *renderer,
+                        egl::Display *display,
+@@ -34,7 +55,8 @@ SurfaceD3D::SurfaceD3D(const egl::SurfaceState &state,
+       mDisplay(display),
+       mFixedSize(window == nullptr || attribs.get(EGL_FIXED_SIZE_ANGLE, EGL_FALSE) == EGL_TRUE),
+       mOrientation(static_cast<EGLint>(attribs.get(EGL_SURFACE_ORIENTATION_ANGLE, 0))),
+-      mRenderTargetFormat(state.config->renderTargetFormat),
++      mColorSpace(static_cast<EGLint>(attribs.get(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_LINEAR_KHR))),
++      mRenderTargetFormat(renderTargetFormatFromColorSpace(display, state.config->renderTargetFormat, mColorSpace)),
+       mDepthStencilFormat(state.config->depthStencilFormat),
+       mSwapChain(nullptr),
+       mSwapIntervalDirty(true),
+@@ -148,7 +170,7 @@ egl::Error SurfaceD3D::resetSwapChain(const egl::Display *display)
+ 
+     mSwapChain =
+         mRenderer->createSwapChain(mNativeWindow, mShareHandle, mD3DTexture, mRenderTargetFormat,
+-                                   mDepthStencilFormat, mOrientation, mState.config->samples);
++                                   mDepthStencilFormat, mOrientation, mState.config->samples, mColorSpace);
+     if (!mSwapChain)
+     {
+         return egl::EglBadAlloc();
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h
+index 01d2573244..ccb793d423 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/SurfaceD3D.h
+@@ -90,6 +90,7 @@ class SurfaceD3D : public SurfaceImpl
+ 
+     bool mFixedSize;
+     GLint mOrientation;
++    EGLint mColorSpace;
+ 
+     GLenum mRenderTargetFormat;
+     GLenum mDepthStencilFormat;
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp
+index b0ef9abddc..f0e497b52f 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.cpp
+@@ -465,6 +465,7 @@ Renderer11::Renderer11(egl::Display *display)
+     mRenderer11DeviceCaps.supportsConstantBufferOffsets = false;
+     mRenderer11DeviceCaps.supportsVpRtIndexWriteFromVertexShader = false;
+     mRenderer11DeviceCaps.supportsDXGI1_2               = false;
++    mRenderer11DeviceCaps.supportsDXGI1_4               = false;
+     mRenderer11DeviceCaps.B5G6R5support                 = 0;
+     mRenderer11DeviceCaps.B4G4R4A4support               = 0;
+     mRenderer11DeviceCaps.B5G5R5A1support               = 0;
+@@ -918,6 +919,7 @@ egl::Error Renderer11::initializeDevice()
+ 
+     // Gather stats on DXGI and D3D feature level
+     ANGLE_HISTOGRAM_BOOLEAN("GPU.ANGLE.SupportsDXGI1_2", mRenderer11DeviceCaps.supportsDXGI1_2);
++    ANGLE_HISTOGRAM_BOOLEAN("GPU.ANGLE.SupportsDXGI1_4", mRenderer11DeviceCaps.supportsDXGI1_4);
+ 
+     ANGLEFeatureLevel angleFeatureLevel = GetANGLEFeatureLevel(mRenderer11DeviceCaps.featureLevel);
+ 
+@@ -1002,6 +1004,10 @@ void Renderer11::populateRenderer11DeviceCaps()
+     IDXGIAdapter2 *dxgiAdapter2 = d3d11::DynamicCastComObject<IDXGIAdapter2>(mDxgiAdapter);
+     mRenderer11DeviceCaps.supportsDXGI1_2 = (dxgiAdapter2 != nullptr);
+     SafeRelease(dxgiAdapter2);
++
++    IDXGIAdapter3 *dxgiAdapter3 = d3d11::DynamicCastComObject<IDXGIAdapter3>(mDxgiAdapter);
++    mRenderer11DeviceCaps.supportsDXGI1_4 = (dxgiAdapter3 != nullptr);
++    SafeRelease(dxgiAdapter3);
+ }
+ 
+ gl::SupportedSampleSet Renderer11::generateSampleSetForEGLConfig(
+@@ -1241,6 +1247,11 @@ void Renderer11::generateDisplayExtensions(egl::DisplayExtensions *outExtensions
+ 
+     // All D3D feature levels support robust resource init
+     outExtensions->robustResourceInitialization = true;
++
++    // color space selection supported in DXGI 1.4 only
++    outExtensions->colorspaceSRGB = mRenderer11DeviceCaps.supportsDXGI1_4;
++    outExtensions->colorspaceSCRGBLinear = mRenderer11DeviceCaps.supportsDXGI1_4;
++    outExtensions->colorspaceBt2020PQ = mRenderer11DeviceCaps.supportsDXGI1_4;
+ }
+ 
+ gl::Error Renderer11::flush()
+@@ -1436,10 +1447,11 @@ SwapChainD3D *Renderer11::createSwapChain(NativeWindowD3D *nativeWindow,
+                                           GLenum backBufferFormat,
+                                           GLenum depthBufferFormat,
+                                           EGLint orientation,
+-                                          EGLint samples)
++                                          EGLint samples,
++                                          EGLint colorSpace)
+ {
+     return new SwapChain11(this, GetAs<NativeWindow11>(nativeWindow), shareHandle, d3dTexture,
+-                           backBufferFormat, depthBufferFormat, orientation, samples);
++                           backBufferFormat, depthBufferFormat, orientation, samples, colorSpace);
+ }
+ 
+ void *Renderer11::getD3DDevice()
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h
+index a8c24e681b..3516bf779d 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/Renderer11.h
+@@ -49,6 +49,7 @@ struct Renderer11DeviceCaps
+ 
+     D3D_FEATURE_LEVEL featureLevel;
+     bool supportsDXGI1_2;                // Support for DXGI 1.2
++    bool supportsDXGI1_4;               // Support for DXGI 1.4
+     bool supportsClearView;              // Support for ID3D11DeviceContext1::ClearView
+     bool supportsConstantBufferOffsets;  // Support for Constant buffer offset
+     bool supportsVpRtIndexWriteFromVertexShader;  // VP/RT can be selected in the Vertex Shader
+@@ -138,7 +139,8 @@ class Renderer11 : public RendererD3D
+                                   GLenum backBufferFormat,
+                                   GLenum depthBufferFormat,
+                                   EGLint orientation,
+-                                  EGLint samples) override;
++                                  EGLint samples,
++                                  EGLint colorSpace) override;
+     egl::Error getD3DTextureInfo(const egl::Config *configuration,
+                                  IUnknown *d3dTexture,
+                                  EGLint *width,
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp
+index dcfd06484d..fc967b90d0 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.cpp
+@@ -18,6 +18,11 @@
+ #include "libANGLE/renderer/d3d/d3d11/texture_format_table.h"
+ #include "third_party/trace_event/trace_event.h"
+ 
++#if 0
++// used only for HDR metadata configuration options
++#include <dxgi1_5.h>
++#endif
++
+ // Precompiled shaders
+ #include "libANGLE/renderer/d3d/d3d11/shaders/compiled/passthrough2d11vs.h"
+ #include "libANGLE/renderer/d3d/d3d11/shaders/compiled/passthroughrgba2d11ps.h"
+@@ -56,12 +61,14 @@ SwapChain11::SwapChain11(Renderer11 *renderer,
+                          GLenum backBufferFormat,
+                          GLenum depthBufferFormat,
+                          EGLint orientation,
+-                         EGLint samples)
++                         EGLint samples,
++                         EGLint colorSpace)
+     : SwapChainD3D(shareHandle, d3dTexture, backBufferFormat, depthBufferFormat),
+       mRenderer(renderer),
+       mWidth(-1),
+       mHeight(-1),
+       mOrientation(orientation),
++      mColorSpace(colorSpace),
+       mAppCreatedShareHandle(mShareHandle != nullptr),
+       mSwapInterval(0),
+       mPassThroughResourcesInit(false),
+@@ -620,10 +627,92 @@ EGLint SwapChain11::reset(const gl::Context *context,
+             mSwapChain1 = d3d11::DynamicCastComObject<IDXGISwapChain1>(mSwapChain);
+         }
+ 
++        if (mRenderer->getRenderer11DeviceCaps().supportsDXGI1_4)
++        {
++            IDXGISwapChain3 *swapChain3 = d3d11::DynamicCastComObject<IDXGISwapChain3>(mSwapChain);
++
++            printf("*** EGL colorSpace: 0x%X\n", mColorSpace);
++            printf("*** EGL format: 0x%X\n", mOffscreenRenderTargetFormat);
++            printf("*** Native format: 0x%X\n", getSwapChainNativeFormat());
++
++            if (mColorSpace != EGL_GL_COLORSPACE_LINEAR_KHR) {
++                DXGI_COLOR_SPACE_TYPE nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
++                switch (mColorSpace)
++                {
++                case EGL_GL_COLORSPACE_SRGB_KHR:
++                    nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
++                    break;
++                case EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT:
++                    nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
++                    break;
++                case EGL_GL_COLORSPACE_BT2020_PQ_EXT:
++                    nativeColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
++                    break;
++                default:
++                    ASSERT(0 && "Unsupported colorspace requested");
++                }
++
++                printf("*** Native colorSpace: 0x%X\n", nativeColorSpace);
++
++                UINT supported = 0;
++                result = swapChain3->CheckColorSpaceSupport(nativeColorSpace, &supported);
++                ASSERT(SUCCEEDED(result));
++                if (!(supported & DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT)) {
++                    SafeRelease(swapChain3);
++                    return EGL_BAD_MATCH;
++                }
++
++                result = swapChain3->SetColorSpace1(nativeColorSpace);
++                ASSERT(SUCCEEDED(result));
++            }
++
++            SafeRelease(swapChain3);
++
++#if 0
++
++            IDXGISwapChain4 *swapChain4 = d3d11::DynamicCastComObject<IDXGISwapChain4>(mSwapChain);
++
++            DXGI_HDR_METADATA_HDR10 md;
++            md.RedPrimary[0] = 0.680 * 50000;
++            md.RedPrimary[1] = 0.320 * 50000;
++            md.GreenPrimary[0] = 0.265 * 50000;
++            md.GreenPrimary[1] = 0.690 * 50000;
++            md.BluePrimary[0] = 0.150 * 50000;
++            md.BluePrimary[1] = 0.060 * 50000;
++            md.WhitePoint[0] = 0.3127 * 50000;
++            md.WhitePoint[1] = 0.3290 * 50000;
++            md.MaxMasteringLuminance = 1000 * 10000;
++            md.MinMasteringLuminance = 0.001 * 10000;
++            md.MaxContentLightLevel = 1000;
++            md.MaxFrameAverageLightLevel = 200;
++            result = swapChain4->SetHDRMetaData(DXGI_HDR_METADATA_TYPE_HDR10, sizeof(md), &md);
++            printf("*** Result hdr 0x%X\n", result);
++            SafeRelease(swapChain4);
++#endif
++        }
++
+         ID3D11Texture2D *backbufferTex = nullptr;
+         result                         = mSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D),
+                                        reinterpret_cast<LPVOID *>(&backbufferTex));
+         ASSERT(SUCCEEDED(result));
++
++        // TODO: recover rendering to sRGB
++        //
++        // D3D11_RENDER_TARGET_VIEW_DESC offscreenRTVDesc;
++        // offscreenRTVDesc.Format = getSwapChainNativeFormat();
++        //
++        // if (mColorSpace == EGL_GL_COLORSPACE_SRGB_KHR) {
++        //     if (offscreenRTVDesc.Format == DXGI_FORMAT_R8G8B8A8_UNORM) {
++        //         offscreenRTVDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
++        //     }
++        //
++        //     if (offscreenRTVDesc.Format == DXGI_FORMAT_B8G8R8A8_UNORM) {
++        //         offscreenRTVDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;
++        //     }
++        // }
++        //
++        // printf("*** Render target format: 0x%X\n", offscreenRTVDesc.Format);
++
+         const auto &format =
+             d3d11::Format::Get(mOffscreenRenderTargetFormat, mRenderer->getRenderer11DeviceCaps());
+         mBackBufferTexture.set(backbufferTex, format);
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h
+index eca068210b..2a4b9ba274 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/SwapChain11.h
+@@ -28,7 +28,8 @@ class SwapChain11 final : public SwapChainD3D
+                 GLenum backBufferFormat,
+                 GLenum depthBufferFormat,
+                 EGLint orientation,
+-                EGLint samples);
++                EGLint samples,
++                EGLint colorSpace);
+     ~SwapChain11() override;
+ 
+     EGLint resize(const gl::Context *context,
+@@ -93,6 +94,7 @@ class SwapChain11 final : public SwapChainD3D
+     EGLint mWidth;
+     EGLint mHeight;
+     const EGLint mOrientation;
++    EGLint mColorSpace;
+     bool mAppCreatedShareHandle;
+     unsigned int mSwapInterval;
+     bool mPassThroughResourcesInit;
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp
+index 5394e3d3e7..af52c41d00 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d11/win32/NativeWindow11Win32.cpp
+@@ -146,6 +146,9 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
+ 
+     // Use IDXGIFactory2::CreateSwapChainForHwnd if DXGI 1.2 is available to create a
+     // DXGI_SWAP_EFFECT_SEQUENTIAL swap chain.
++    //
++    // NOTE: in non-flip mode HDR rendering is not supported, so use it
++    //       by default
+     IDXGIFactory2 *factory2 = d3d11::DynamicCastComObject<IDXGIFactory2>(factory);
+     if (factory2 != nullptr)
+     {
+@@ -158,9 +161,9 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
+         swapChainDesc.SampleDesc.Quality    = 0;
+         swapChainDesc.BufferUsage =
+             DXGI_USAGE_RENDER_TARGET_OUTPUT | DXGI_USAGE_SHADER_INPUT | DXGI_USAGE_BACK_BUFFER;
+-        swapChainDesc.BufferCount   = 1;
++        swapChainDesc.BufferCount   = 2;
+         swapChainDesc.Scaling       = DXGI_SCALING_STRETCH;
+-        swapChainDesc.SwapEffect    = DXGI_SWAP_EFFECT_SEQUENTIAL;
++        swapChainDesc.SwapEffect    = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
+         swapChainDesc.AlphaMode     = DXGI_ALPHA_MODE_UNSPECIFIED;
+         swapChainDesc.Flags         = 0;
+         IDXGISwapChain1 *swapChain1 = nullptr;
+@@ -176,7 +179,7 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
+     }
+ 
+     DXGI_SWAP_CHAIN_DESC swapChainDesc               = {};
+-    swapChainDesc.BufferCount                        = 1;
++    swapChainDesc.BufferCount                        = 2;
+     swapChainDesc.BufferDesc.Format                  = format;
+     swapChainDesc.BufferDesc.Width                   = width;
+     swapChainDesc.BufferDesc.Height                  = height;
+@@ -191,6 +194,16 @@ HRESULT NativeWindow11Win32::createSwapChain(ID3D11Device *device,
+     swapChainDesc.SampleDesc.Count   = samples;
+     swapChainDesc.SampleDesc.Quality = 0;
+     swapChainDesc.Windowed           = TRUE;
++
++    /**
++     * NOTE1: in discard mode the swap chain doesn't support partial
++     *        presentatiopn with Present1() call. Though it is not a big
++     *        problem, because in case DXGI 1.2 is supported this code is
++     *        unreachable.
++     *
++     * NOTE2: Flip modes are not supported on Windows 7 and the like,
++     *        so use a legacy mode as a fallback
++     */
+     swapChainDesc.SwapEffect         = DXGI_SWAP_EFFECT_DISCARD;
+ 
+     HRESULT result = factory->CreateSwapChain(device, &swapChainDesc, swapChain);
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
+index 75c6298868..58596169a8 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
+@@ -718,8 +718,10 @@ SwapChainD3D *Renderer9::createSwapChain(NativeWindowD3D *nativeWindow,
+                                          GLenum backBufferFormat,
+                                          GLenum depthBufferFormat,
+                                          EGLint orientation,
+-                                         EGLint samples)
++                                         EGLint samples,
++                                         EGLint colorSpace)
+ {
++    UNUSED_VARIABLE(colorSpace);
+     return new SwapChain9(this, GetAs<NativeWindow9>(nativeWindow), shareHandle, d3dTexture,
+                           backBufferFormat, depthBufferFormat, orientation);
+ }
+diff --git a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h
+index 9ddee45f0f..ce4bb201e5 100644
+--- a/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h
++++ b/src/3rdparty/angle/src/libANGLE/renderer/d3d/d3d9/Renderer9.h
+@@ -92,7 +92,8 @@ class Renderer9 : public RendererD3D
+                                   GLenum backBufferFormat,
+                                   GLenum depthBufferFormat,
+                                   EGLint orientation,
+-                                  EGLint samples) override;
++                                  EGLint samples,
++                                  EGLint colorSpace) override;
+     egl::Error getD3DTextureInfo(const egl::Config *configuration,
+                                  IUnknown *d3dTexture,
+                                  EGLint *width,
+diff --git a/src/3rdparty/angle/src/libANGLE/validationEGL.cpp b/src/3rdparty/angle/src/libANGLE/validationEGL.cpp
+index 13a3a9e280..858d7ee929 100644
+--- a/src/3rdparty/angle/src/libANGLE/validationEGL.cpp
++++ b/src/3rdparty/angle/src/libANGLE/validationEGL.cpp
+@@ -885,6 +885,32 @@ Error ValidateCreateWindowSurface(Display *display, Config *config, EGLNativeWin
+                                               "either EGL_TRUE or EGL_FALSE.";
+               }
+               break;
++          case EGL_GL_COLORSPACE:
++
++              if (!displayExtensions.colorspaceSRGB)
++              {
++                  return EglBadAttribute() << "EGL_KHR_gl_colorspace is not supported on this platform.";
++              }
++
++              if (value == EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT)
++              {
++                  if (!displayExtensions.colorspaceSCRGBLinear)
++                  {
++                      return EglBadAttribute() << "EGL_EXT_gl_colorspace_scrgb_linear is not supported on this platform.";
++                  }
++              }
++              else if (value == EGL_GL_COLORSPACE_BT2020_PQ_EXT)
++              {
++                  if (!displayExtensions.colorspaceBt2020PQ)
++                  {
++                      return EglBadAttribute() << "EGL_EXT_gl_colorspace_bt2020_pq is not supported on this platform.";
++                  }
++              }
++              else if (value != EGL_GL_COLORSPACE_SRGB_KHR && value != EGL_GL_COLORSPACE_LINEAR_KHR)
++              {
++                  return EglBadAttribute() << "Unknown EGL color space requested";
++              }
++              break;
+ 
+           default:
+               return EglBadAttribute();
+@@ -977,6 +1003,33 @@ Error ValidateCreatePbufferSurface(Display *display, Config *config, const Attri
+               }
+               break;
+ 
++        case EGL_GL_COLORSPACE:
++
++            if (!displayExtensions.colorspaceSRGB)
++            {
++                return EglBadAttribute() << "EGL_KHR_gl_colorspace is not supported on this platform.";
++            }
++
++            if (value == EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT)
++            {
++                if (!displayExtensions.colorspaceSCRGBLinear)
++                {
++                    return EglBadAttribute() << "EGL_EXT_gl_colorspace_scrgb_linear is not supported on this platform.";
++                }
++            }
++            else if (value == EGL_GL_COLORSPACE_BT2020_PQ_EXT)
++            {
++                if (!displayExtensions.colorspaceBt2020PQ)
++                {
++                    return EglBadAttribute() << "EGL_EXT_gl_colorspace_bt2020_pq is not supported on this platform.";
++                }
++            }
++            else if (value != EGL_GL_COLORSPACE_SRGB_KHR && value != EGL_GL_COLORSPACE_LINEAR_KHR)
++            {
++                return EglBadAttribute() << "Unknown EGL color space requested";
++            }
++            break;
++
+           default:
+               return EglBadAttribute();
+         }
+-- 
+2.20.1.windows.1
+
-- 
2.22.0.windows.1

From 50d5c432a7a7b793750b07b7638f88cb587fb37b Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Wed, 13 Feb 2019 16:56:11 +0300
Subject: [PATCH 05/27] Implement color space selection for QSurfaceFormat

With the patch one can select color space of openGL surface
which is used a a root surface of the underlying native window.

This feature is needed, e.g. when the user wants to render HDR
content on screen. In such a case OS should be instructed about
how to treat the graphical data in the application framebuffer.

The easiest approach is to call QSurfaceFormat::setDefaultFormat()
before creating the first application window. In such a case the
root surface will (may) be in the requested format.

Supported color spaces/formats:

1) sRGB, SDR
2) scRGB (Rec 709, gamma 1.0), HDR
3) Rec 2020 PQ, HDR

Please take into account that in real life the user should select
proper bit depth for each color space, otherwise the system will
refuse to create the surface:

1) sRGB --- 8 bit or 10 bit
2) scRGB --- 16 bit only
3) Rec 2020 PQ --- 10 bit only

Please note that color space selection is supported only on
platforms with DXGI 1.4 and higher.

Change-Id: I5f4945db9798d542f19c8ff1af1effa34f7745fd
---
 src/gui/kernel/qsurfaceformat.cpp             | 11 ++++
 src/gui/kernel/qsurfaceformat.h               |  4 +-
 src/gui/opengl/qopenglframebufferobject.cpp   |  7 ++-
 .../platforms/windows/qwindowseglcontext.cpp  | 57 +++++++++++++++++--
 .../platforms/windows/qwindowseglcontext.h    |  6 +-
 .../platforms/windows/qwindowsopenglcontext.h |  2 +-
 .../platforms/windows/qwindowswindow.cpp      |  8 ++-
 7 files changed, 83 insertions(+), 12 deletions(-)

diff --git a/src/gui/kernel/qsurfaceformat.cpp b/src/gui/kernel/qsurfaceformat.cpp
index 1a814ec2..fc8b9c4f 100644
--- a/src/gui/kernel/qsurfaceformat.cpp
+++ b/src/gui/kernel/qsurfaceformat.cpp
@@ -221,6 +221,17 @@ public:
     set, the window will be created with an sRGB-capable default
     framebuffer. Note that some platforms may return windows with a sRGB-capable
     default framebuffer even when not requested explicitly.
+
+    \value scRGBColorSpace When \c{EGL_EXT_gl_colorspace_scrgb_linear}
+    is supported by the platform and this value is set, the window will
+    be created with an scRGB-capable default framebuffer. Note that some
+    platforms may return windows with a scRGB-capable default framebuffer
+    even when not requested explicitly. It usually happens when the application
+    requests 16-bit surface format.
+
+    \value bt2020PQColorSpace When \c{EGL_EXT_gl_colorspace_bt2020_pq}
+    is supported by the platform and this value is set, the window will
+    be created with an bt2020 PQ default framebuffer.
  */
 
 /*!
diff --git a/src/gui/kernel/qsurfaceformat.h b/src/gui/kernel/qsurfaceformat.h
index ed63eb8b..9ba6a29b 100644
--- a/src/gui/kernel/qsurfaceformat.h
+++ b/src/gui/kernel/qsurfaceformat.h
@@ -87,7 +87,9 @@ public:
 
     enum ColorSpace {
         DefaultColorSpace,
-        sRGBColorSpace
+        sRGBColorSpace,
+        scRGBColorSpace,
+        bt2020PQColorSpace
     };
     Q_ENUM(ColorSpace)
 
diff --git a/src/gui/opengl/qopenglframebufferobject.cpp b/src/gui/opengl/qopenglframebufferobject.cpp
index cae3d516..ccdccb63 100644
--- a/src/gui/opengl/qopenglframebufferobject.cpp
+++ b/src/gui/opengl/qopenglframebufferobject.cpp
@@ -545,10 +545,13 @@ void QOpenGLFramebufferObjectPrivate::initTexture(int idx)
     ColorAttachment &color(colorAttachments[idx]);
 
     GLuint pixelType = GL_UNSIGNED_BYTE;
-    if (color.internalFormat == GL_RGB10_A2 || color.internalFormat == GL_RGB10)
+    if (color.internalFormat == GL_RGB10_A2 || color.internalFormat == GL_RGB10) {
         pixelType = GL_UNSIGNED_INT_2_10_10_10_REV;
-    else if (color.internalFormat == GL_RGB16  || color.internalFormat == GL_RGBA16)
+    } else if (color.internalFormat == GL_RGB16  || color.internalFormat == GL_RGBA16) {
         pixelType = GL_UNSIGNED_SHORT;
+    } else if (color.internalFormat == GL_RGBA16F) {
+        pixelType = GL_HALF_FLOAT;
+    }
 
     funcs.glTexImage2D(target, 0, color.internalFormat, color.size.width(), color.size.height(), 0,
                        GL_RGBA, pixelType, NULL);
diff --git a/src/plugins/platforms/windows/qwindowseglcontext.cpp b/src/plugins/platforms/windows/qwindowseglcontext.cpp
index 063e8115..4cd745ea 100644
--- a/src/plugins/platforms/windows/qwindowseglcontext.cpp
+++ b/src/plugins/platforms/windows/qwindowseglcontext.cpp
@@ -151,8 +151,9 @@ bool QWindowsLibEGL::init()
     eglGetCurrentDisplay = RESOLVE((EGLDisplay (EGLAPIENTRY *)(void)), eglGetCurrentDisplay);
     eglSwapBuffers = RESOLVE((EGLBoolean (EGLAPIENTRY *)(EGLDisplay , EGLSurface)), eglSwapBuffers);
     eglGetProcAddress = RESOLVE((QFunctionPointer (EGLAPIENTRY * )(const char *)), eglGetProcAddress);
+    eglQueryString = RESOLVE((const char* (EGLAPIENTRY *)(EGLDisplay, EGLint)), eglQueryString);
 
-    if (!eglGetError || !eglGetDisplay || !eglInitialize || !eglGetProcAddress)
+    if (!eglGetError || !eglGetDisplay || !eglInitialize || !eglGetProcAddress || !eglQueryString)
         return false;
 
     eglGetPlatformDisplayEXT = nullptr;
@@ -197,8 +198,15 @@ bool QWindowsLibGLESv2::init()
 }
 
 QWindowsEGLStaticContext::QWindowsEGLStaticContext(EGLDisplay display)
-    : m_display(display)
+    : m_display(display),
+      m_hasSRGBColorSpaceSupport(false),
+      m_hasSCRGBColorSpaceSupport(false),
+      m_hasBt2020PQColorSpaceSupport(false)
 {
+    const char *eglExtensions = libEGL.eglQueryString(display, EGL_EXTENSIONS);
+    m_hasSRGBColorSpaceSupport = strstr(eglExtensions, "EGL_KHR_gl_colorspace") != nullptr;
+    m_hasSCRGBColorSpaceSupport = strstr(eglExtensions, "EGL_EXT_gl_colorspace_scrgb_linear") != nullptr;
+    m_hasBt2020PQColorSpaceSupport = strstr(eglExtensions, "EGL_EXT_gl_colorspace_bt2020_pq") != nullptr;
 }
 
 bool QWindowsEGLStaticContext::initializeAngle(QWindowsOpenGLTester::Renderers preferredType, HDC dc,
@@ -297,11 +305,48 @@ QWindowsOpenGLContext *QWindowsEGLStaticContext::createContext(QOpenGLContext *c
     return new QWindowsEGLContext(this, context->format(), context->shareHandle());
 }
 
-void *QWindowsEGLStaticContext::createWindowSurface(void *nativeWindow, void *nativeConfig, int *err)
+void *QWindowsEGLStaticContext::createWindowSurface(void *nativeWindow, void *nativeConfig,
+                                                    QSurfaceFormat::ColorSpace colorSpace, int *err)
 {
     *err = 0;
+
+    EGLint eglColorSpace = EGL_GL_COLORSPACE_LINEAR_KHR;
+    bool colorSpaceSupported = false;
+
+    switch (colorSpace) {
+    case QSurfaceFormat::DefaultColorSpace:
+        colorSpaceSupported = m_hasSRGBColorSpaceSupport;
+        break;
+    case QSurfaceFormat::sRGBColorSpace:
+        eglColorSpace = EGL_GL_COLORSPACE_SRGB_KHR;
+        colorSpaceSupported = m_hasSRGBColorSpaceSupport;
+        break;
+    case QSurfaceFormat::scRGBColorSpace:
+        eglColorSpace = EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT;
+        colorSpaceSupported = m_hasSCRGBColorSpaceSupport;
+        break;
+    case QSurfaceFormat::bt2020PQColorSpace:
+        eglColorSpace = EGL_GL_COLORSPACE_BT2020_PQ_EXT;
+        colorSpaceSupported = m_hasBt2020PQColorSpaceSupport;
+        break;
+    }
+
+    QVector<EGLint> attributes;
+
+    if (colorSpaceSupported) {
+        attributes << EGL_GL_COLORSPACE << eglColorSpace;
+    }
+
+    attributes << EGL_NONE;
+
+    if (!colorSpaceSupported && colorSpace != QSurfaceFormat::DefaultColorSpace) {
+        qWarning().nospace() << __FUNCTION__ << ": Requested color space is not supported by EGL implementation: " << colorSpace << " (egl: 0x" << hex << eglColorSpace << ")";
+    }
+
+
     EGLSurface surface = libEGL.eglCreateWindowSurface(m_display, nativeConfig,
-                                                       static_cast<EGLNativeWindowType>(nativeWindow), nullptr);
+                                                       static_cast<EGLNativeWindowType>(nativeWindow),
+                                                       attributes.constData());
     if (surface == EGL_NO_SURFACE) {
         *err = libEGL.eglGetError();
         qWarning("%s: Could not create the EGL window surface: 0x%x", __FUNCTION__, *err);
@@ -349,6 +394,7 @@ QSurfaceFormat QWindowsEGLStaticContext::formatFromConfig(EGLDisplay display, EG
     format.setSamples(sampleCount);
     format.setStereo(false);
     format.setSwapInterval(referenceFormat.swapInterval());
+    format.setColorSpace(referenceFormat.colorSpace());
 
     // Clear the EGL error state because some of the above may
     // have errored out because the attribute is not applicable
@@ -378,7 +424,6 @@ QSurfaceFormat QWindowsEGLStaticContext::formatFromConfig(EGLDisplay display, EG
     \internal
     \ingroup qt-lighthouse-win
 */
-
 QWindowsEGLContext::QWindowsEGLContext(QWindowsEGLStaticContext *staticContext,
                                        const QSurfaceFormat &format,
                                        QPlatformOpenGLContext *share)
@@ -483,6 +528,8 @@ bool QWindowsEGLContext::makeCurrent(QPlatformSurface *surface)
             // Simulate context loss as the context is useless.
             QWindowsEGLStaticContext::libEGL.eglDestroyContext(m_eglDisplay, m_eglContext);
             m_eglContext = EGL_NO_CONTEXT;
+        } else if (err == EGL_BAD_MATCH) {
+            qCDebug(lcQpaGl) << "Got bad match in createWindowSurface() for context" << this << "Check color space configuration.";
         }
         return false;
     }
diff --git a/src/plugins/platforms/windows/qwindowseglcontext.h b/src/plugins/platforms/windows/qwindowseglcontext.h
index 8a1e1dda..9f7742e6 100644
--- a/src/plugins/platforms/windows/qwindowseglcontext.h
+++ b/src/plugins/platforms/windows/qwindowseglcontext.h
@@ -80,6 +80,7 @@ struct QWindowsLibEGL
     QFunctionPointer (EGLAPIENTRY *eglGetProcAddress)(const char *procname);
 
     EGLDisplay (EGLAPIENTRY * eglGetPlatformDisplayEXT)(EGLenum platform, void *native_display, const EGLint *attrib_list);
+    const char* (EGLAPIENTRY * eglQueryString)(EGLDisplay dpy, EGLint name);
 
 private:
 #if !defined(QT_STATIC) || defined(QT_OPENGL_DYNAMIC)
@@ -121,7 +122,7 @@ public:
     void *moduleHandle() const override { return libGLESv2.moduleHandle(); }
     QOpenGLContext::OpenGLModuleType moduleType() const override { return QOpenGLContext::LibGLES; }
 
-    void *createWindowSurface(void *nativeWindow, void *nativeConfig, int *err) override;
+    void *createWindowSurface(void *nativeWindow, void *nativeConfig, QSurfaceFormat::ColorSpace colorSpace, int *err) override;
     void destroyWindowSurface(void *nativeSurface) override;
 
     QSurfaceFormat formatFromConfig(EGLDisplay display, EGLConfig config, const QSurfaceFormat &referenceFormat);
@@ -135,6 +136,9 @@ private:
                                 EGLDisplay *display, EGLint *major, EGLint *minor);
 
     const EGLDisplay m_display;
+    bool m_hasSRGBColorSpaceSupport;
+    bool m_hasSCRGBColorSpaceSupport;
+    bool m_hasBt2020PQColorSpaceSupport;
 };
 
 class QWindowsEGLContext : public QWindowsOpenGLContext
diff --git a/src/plugins/platforms/windows/qwindowsopenglcontext.h b/src/plugins/platforms/windows/qwindowsopenglcontext.h
index cc6d93d3..61c0e287 100644
--- a/src/plugins/platforms/windows/qwindowsopenglcontext.h
+++ b/src/plugins/platforms/windows/qwindowsopenglcontext.h
@@ -63,7 +63,7 @@ public:
 
     // If the windowing system interface needs explicitly created window surfaces (like EGL),
     // reimplement these.
-    virtual void *createWindowSurface(void * /*nativeWindow*/, void * /*nativeConfig*/, int * /*err*/) { return 0; }
+    virtual void *createWindowSurface(void * /*nativeWindow*/, void * /*nativeConfig*/, QSurfaceFormat::ColorSpace /*colorSpace*/, int * /*err*/) { return 0; }
     virtual void destroyWindowSurface(void * /*nativeSurface*/) { }
 
 protected:
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index 0376e363..76a443a8 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -2741,9 +2741,13 @@ void *QWindowsWindow::surface(void *nativeConfig, int *err)
     return 0;
 #endif
 #ifndef QT_NO_OPENGL
+
+
+
     if (!m_surface) {
-        if (QWindowsStaticOpenGLContext *staticOpenGLContext = QWindowsIntegration::staticOpenGLContext())
-            m_surface = staticOpenGLContext->createWindowSurface(m_data.hwnd, nativeConfig, err);
+        if (QWindowsStaticOpenGLContext *staticOpenGLContext = QWindowsIntegration::staticOpenGLContext()) {
+            m_surface = staticOpenGLContext->createWindowSurface(m_data.hwnd, nativeConfig, m_format.colorSpace(), err);
+        }
     }
 
     return m_surface;
-- 
2.22.0.windows.1

From db1a31e31a3ab3df369135ba0665b557a60691f7 Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Thu, 22 Nov 2018 15:47:48 +0300
Subject: [PATCH 06/27] Implement color conversion for the backing store
 texture

If the window surface is not in sRGB mode, then the backing store
surface should be converted into the destinations color space.

This patch adds the most popular color space transitions into
QOpenGLTextureBlitter.

The patch also implements QOpenGLWidget::setTextureColorSpace(),
which notifies the compositor about the color space of non-native
openGL widgets, so that the data could be converted correctly.

TODO: should we implement the same for QOpenGLWindow::
      setTextureColorSpace()?

Note:
The channels should be swizzled into RGBA *before* applying the
color space conversion matrix. Otherwise the colors will be skewed,
because the conversion function for R and B channels is not the same.

Change-Id: Icbf599952c93cc04de417d0c3790a65282741655
---
 src/gui/opengl/qopengltextureblitter.cpp      | 222 ++++++++++++++++--
 src/gui/opengl/qopengltextureblitter.h        |  12 +-
 src/gui/painting/qplatformbackingstore.cpp    |  16 +-
 src/gui/painting/qplatformbackingstore.h      |   4 +-
 .../qopenglcompositorbackingstore.cpp         |   2 +-
 src/widgets/kernel/qopenglwidget.cpp          |  45 +++-
 src/widgets/kernel/qopenglwidget.h            |   3 +
 src/widgets/kernel/qwidget_p.h                |   1 +
 src/widgets/kernel/qwidgetbackingstore.cpp    |   2 +-
 9 files changed, 281 insertions(+), 26 deletions(-)

diff --git a/src/gui/opengl/qopengltextureblitter.cpp b/src/gui/opengl/qopengltextureblitter.cpp
index b65df9dc..5f6dbff2 100644
--- a/src/gui/opengl/qopengltextureblitter.cpp
+++ b/src/gui/opengl/qopengltextureblitter.cpp
@@ -131,14 +131,85 @@ static const char vertex_shader[] =
     "}";
 
 static const char fragment_shader[] =
-    "varying highp vec2 uv;"
-    "uniform sampler2D textureSampler;"
-    "uniform bool swizzle;"
-    "uniform highp float opacity;"
+    "varying highp vec2 uv;\n"
+    "uniform sampler2D textureSampler;\n"
+    "uniform bool swizzle;\n"
+    "uniform highp float opacity;\n"
+    "#if defined SCRGB_TO_SRGB\n"
+    "highp vec4 linearToSRGB(highp vec4 value)\n"
+    "{\n"
+    "   bvec4 cutoff = lessThan(value, vec4(0.0031308));\n"
+    "   const highp vec2 a1 = vec2(0.055, 0.0);\n"
+    "   const highp vec2 c2 = vec2(1.055, 1.0);\n"
+    "   const highp vec2 m3 = vec2(2.4, 1.0);\n"
+    "   const highp vec2 c4 = vec2(12.92, 1.0);\n"
+    "   highp vec4 higher = c2.xxxy * pow(value, 1.0 / m3.xxxy) - a1.xxxy;\n"
+    "   highp vec4 lower = value * c4.xxxy;\n"
+    "   return mix(higher, lower, vec4(cutoff));\n"
+    "}\n"
+    "#endif\n"
+    "#if defined SRGB_TO_SCRGB || defined SRGB_TO_BT2020PQ || defined SCRGB_TO_BT2020PQ\n"
+    "highp vec4 sRgbToLinear(highp vec4 sRGB)\n"
+    "{\n"
+    "   bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n"
+    "   const highp vec2 a1 = vec2(0.055, 0.0);\n"
+    "   const highp vec2 c2 = vec2(1.055, 1.0);\n"
+    "   const highp vec2 m3 = vec2(2.4, 1.0);\n"
+    "   const highp vec2 c4 = vec2(12.92, 1.0);\n"
+    "   highp vec4 higher = pow((sRGB + a1.xxxy) / c2.xxxy, m3.xxxy);\n"
+    "   highp vec4 lower = sRGB / c4.xxxy;\n"
+    "   return mix(higher, lower, vec4(cutoff));\n"
+    "}\n"
+    "#endif\n"
+    "#if defined SRGB_TO_BT2020PQ || defined SCRGB_TO_BT2020PQ\n"
+    "highp vec4 applySmpte2084Curve(highp vec4 L)\n"
+    "{"
+    "   const highp vec2 m1 = vec2(2610.0 / 4096.0 / 4.0, 1.0);\n"
+    "   const highp vec2 m2 = vec2(2523.0 / 4096.0 * 128.0, 1.0);\n"
+    "   const highp vec2 a1 = vec2(3424.0 / 4096.0, 0.0);\n"
+    "   const highp vec2 c2 = vec2(2413.0 / 4096.0 * 32.0, 1.0);\n"
+    "   const highp vec2 c3 = vec2(2392.0 / 4096.0 * 32.0, 1.0);\n"
+    "   const highp vec2 a4 = vec2(1.0, 0.0);\n"
+    "   highp vec4 Lp = pow(L, m1.xxxy);\n"
+    "   highp vec4 res = pow((a1.xxxy + c2.xxxy * Lp) / (a4.xxxy + c3.xxxy * Lp), m2.xxxy);\n"
+    "   return res;"
+    "}\n"
+    "#endif\n"
+    "#if defined SRGB_TO_BT2020PQ || defined SCRGB_TO_BT2020PQ\n"
+    "highp vec4 scRgbToBt2020pq(highp vec4 value)\n"
+    "{\n"
+    "   const highp mat4 convMat = "
+    "      mat4(0.627402, 0.069095, 0.016394, 0.0,"
+    "           0.329292, 0.919544, 0.088028, 0.0,"
+    "           0.043306, 0.011360, 0.895578, 0.0,"
+    "           0.0,      0.0,      0.0,      1.0);"
+    ""
+    "   value = convMat * value;\n"
+    "   return applySmpte2084Curve(0.008 * value);"
+    "}\n"
+    "#endif\n"
+    "#if defined SRGB_TO_BT2020PQ\n"
+    "highp vec4 sRgbToBt2020pq(highp vec4 value)\n"
+    "{\n"
+    "   value = sRgbToLinear(value);"
+    "   return scRgbToBt2020pq(value);"
+    "}\n"
+    "#endif\n"
+    "\n"
     "void main() {"
     "   highp vec4 tmpFragColor = texture2D(textureSampler,uv);"
-    "   tmpFragColor.a *= opacity;"
-    "   gl_FragColor = swizzle ? tmpFragColor.bgra : tmpFragColor;"
+    "   tmpFragColor.a *= opacity;\n"
+    "   tmpFragColor = swizzle ? tmpFragColor.bgra : tmpFragColor;\n"
+    "#if defined SRGB_TO_SCRGB\n"
+    "   tmpFragColor = sRgbToLinear(tmpFragColor);\n"
+    "#elif defined SRGB_TO_BT2020PQ\n"
+    "   tmpFragColor = sRgbToBt2020pq(tmpFragColor);\n"
+    "#elif defined SCRGB_TO_BT2020PQ\n"
+    "   tmpFragColor = scRgbToBt2020pq(tmpFragColor);\n"
+    "#elif defined SCRGB_TO_SRGB\n"
+    "   tmpFragColor = linearToSRGB(tmpFragColor);\n"
+    "#endif\n"
+    "   gl_FragColor = tmpFragColor;"
     "}";
 
 static const char fragment_shader_external_oes[] =
@@ -187,6 +258,23 @@ private:
     GLenum m_target;
 };
 
+class ColorSpaceConversion : public QPair<QSurfaceFormat::ColorSpace, QSurfaceFormat::ColorSpace>
+{
+public:
+    ColorSpaceConversion() { };
+    ColorSpaceConversion(QSurfaceFormat::ColorSpace srcColorSpace,
+                         QSurfaceFormat::ColorSpace dstColorSpace)
+        : QPair(srcColorSpace, dstColorSpace)
+    { }
+
+    QSurfaceFormat::ColorSpace source() const {
+        return first;
+    }
+    QSurfaceFormat::ColorSpace destination() const {
+        return second;
+    }
+};
+
 class QOpenGLTextureBlitterPrivate
 {
 public:
@@ -197,16 +285,29 @@ public:
     };
 
     enum ProgramIndex {
-        TEXTURE_2D,
-        TEXTURE_EXTERNAL_OES
+        TEXTURE_2D = 0,
+        TEXTURE_2D_SRGB_TO_SCRGB,
+        TEXTURE_2D_SCRGB_TO_SRGB,
+        TEXTURE_2D_SRGB_TO_BT2020PQ,
+        TEXTURE_2D_SCRGB_TO_BT2020PQ,
+        TEXTURE_EXTERNAL_OES,
+
+        PROGRAM_COUNT
     };
 
     QOpenGLTextureBlitterPrivate() :
         swizzle(false),
         opacity(1.0f),
         vao(new QOpenGLVertexArrayObject),
-        currentTarget(TEXTURE_2D)
-    { }
+        currentTarget(GL_NONE),
+        colorSpaceConversion(0)
+    {
+        supportedColorSpaceConversions << ColorSpaceConversion(QSurfaceFormat::DefaultColorSpace, QSurfaceFormat::DefaultColorSpace);
+        supportedColorSpaceConversions << ColorSpaceConversion(QSurfaceFormat::sRGBColorSpace, QSurfaceFormat::scRGBColorSpace);
+        supportedColorSpaceConversions << ColorSpaceConversion(QSurfaceFormat::scRGBColorSpace, QSurfaceFormat::sRGBColorSpace);
+        supportedColorSpaceConversions << ColorSpaceConversion(QSurfaceFormat::sRGBColorSpace, QSurfaceFormat::bt2020PQColorSpace);
+        supportedColorSpaceConversions << ColorSpaceConversion(QSurfaceFormat::scRGBColorSpace, QSurfaceFormat::bt2020PQColorSpace);
+    }
 
     bool buildProgram(ProgramIndex idx, const char *vs, const char *fs);
 
@@ -214,6 +315,7 @@ public:
     void blit(GLuint texture, const QMatrix4x4 &vertexTransform, QOpenGLTextureBlitter::Origin origin);
 
     void prepareProgram(const QMatrix4x4 &vertexTransform);
+    int calcColorSpaceConversionIndex(QSurfaceFormat::ColorSpace srcColorSpace, QSurfaceFormat::ColorSpace dstColorSpace);
 
     QOpenGLBuffer vertexBuffer;
     QOpenGLBuffer textureBuffer;
@@ -239,18 +341,48 @@ public:
         bool swizzle;
         float opacity;
         TextureMatrixUniform textureMatrixUniformState;
-    } programs[2];
+    } programs[PROGRAM_COUNT];
     bool swizzle;
     float opacity;
     QScopedPointer<QOpenGLVertexArrayObject> vao;
     GLenum currentTarget;
+
+    int colorSpaceConversion;
+    QVector<ColorSpaceConversion> supportedColorSpaceConversions;
 };
 
-static inline QOpenGLTextureBlitterPrivate::ProgramIndex targetToProgramIndex(GLenum target)
+int QOpenGLTextureBlitterPrivate::calcColorSpaceConversionIndex(QSurfaceFormat::ColorSpace srcColorSpace, QSurfaceFormat::ColorSpace dstColorSpace)
+{
+    // TODO: auto-detect destination color space of the surface
+    //       in case of default color space
+
+    // disable color management if at least one of the color
+    // spaces is declared as default
+    if (srcColorSpace == QSurfaceFormat::DefaultColorSpace ||
+        dstColorSpace == QSurfaceFormat::DefaultColorSpace) {
+
+        return 0;
+    }
+
+    // disable color management if source and destination color
+    // spaces are the same
+    if (srcColorSpace == dstColorSpace) {
+        return 0;
+    }
+
+    ColorSpaceConversion conversion(srcColorSpace, dstColorSpace);
+    return supportedColorSpaceConversions.indexOf(conversion);
+}
+
+static inline QOpenGLTextureBlitterPrivate::ProgramIndex targetToProgramIndex(GLenum target, int colorSpaceConversion)
 {
     switch (target) {
-    case GL_TEXTURE_2D:
-        return QOpenGLTextureBlitterPrivate::TEXTURE_2D;
+    case GL_TEXTURE_2D: {
+        QOpenGLTextureBlitterPrivate::ProgramIndex index =
+            QOpenGLTextureBlitterPrivate::ProgramIndex(
+                int(QOpenGLTextureBlitterPrivate::TEXTURE_2D) + colorSpaceConversion);
+        return index;
+    }
     case GL_TEXTURE_EXTERNAL_OES:
         return QOpenGLTextureBlitterPrivate::TEXTURE_EXTERNAL_OES;
     default:
@@ -261,7 +393,7 @@ static inline QOpenGLTextureBlitterPrivate::ProgramIndex targetToProgramIndex(GL
 
 void QOpenGLTextureBlitterPrivate::prepareProgram(const QMatrix4x4 &vertexTransform)
 {
-    Program *program = &programs[targetToProgramIndex(currentTarget)];
+    Program *program = &programs[targetToProgramIndex(currentTarget, colorSpaceConversion)];
 
     vertexBuffer.bind();
     program->glProgram->setAttributeBuffer(program->vertexCoordAttribPos, GL_FLOAT, 0, 3, 0);
@@ -293,7 +425,7 @@ void QOpenGLTextureBlitterPrivate::blit(GLuint texture,
     TextureBinder binder(currentTarget, texture);
     prepareProgram(vertexTransform);
 
-    Program *program = &programs[targetToProgramIndex(currentTarget)];
+    Program *program = &programs[targetToProgramIndex(currentTarget, colorSpaceConversion)];
     program->glProgram->setUniformValue(program->textureTransformUniformPos, textureTransform);
     program->textureMatrixUniformState = User;
 
@@ -307,7 +439,7 @@ void QOpenGLTextureBlitterPrivate::blit(GLuint texture,
     TextureBinder binder(currentTarget, texture);
     prepareProgram(vertexTransform);
 
-    Program *program = &programs[targetToProgramIndex(currentTarget)];
+    Program *program = &programs[targetToProgramIndex(currentTarget, colorSpaceConversion)];
     if (origin == QOpenGLTextureBlitter::OriginTopLeft) {
         if (program->textureMatrixUniformState != IdentityFlipped) {
             QMatrix3x3 flipped;
@@ -408,6 +540,28 @@ bool QOpenGLTextureBlitter::create()
     } else {
         if (!d->buildProgram(QOpenGLTextureBlitterPrivate::TEXTURE_2D, vertex_shader, fragment_shader))
             return false;
+
+        // TODO: create non-default transformations on-demand
+        {
+            const QString shader = QString("#define SRGB_TO_SCRGB\n %1").arg(fragment_shader);
+            if (!d->buildProgram(QOpenGLTextureBlitterPrivate::TEXTURE_2D_SRGB_TO_SCRGB, vertex_shader, shader.toLatin1().constData()))
+                return false;
+        }
+        {
+            const QString shader = QString("#define SCRGB_TO_SRGB\n %1").arg(fragment_shader);
+            if (!d->buildProgram(QOpenGLTextureBlitterPrivate::TEXTURE_2D_SCRGB_TO_SRGB, vertex_shader, shader.toLatin1().constData()))
+                return false;
+        }
+        {
+            const QString shader = QString("#define SRGB_TO_BT2020PQ\n %1").arg(fragment_shader);
+            if (!d->buildProgram(QOpenGLTextureBlitterPrivate::TEXTURE_2D_SRGB_TO_BT2020PQ, vertex_shader, shader.toLatin1().constData()))
+                return false;
+        }
+        {
+            const QString shader = QString("#define SCRGB_TO_BT2020PQ\n %1").arg(fragment_shader);
+            if (!d->buildProgram(QOpenGLTextureBlitterPrivate::TEXTURE_2D_SCRGB_TO_BT2020PQ, vertex_shader, shader.toLatin1().constData()))
+                return false;
+        }
         if (supportsExternalOESTarget())
             if (!d->buildProgram(QOpenGLTextureBlitterPrivate::TEXTURE_EXTERNAL_OES, vertex_shader, fragment_shader_external_oes))
                 return false;
@@ -455,6 +609,8 @@ void QOpenGLTextureBlitter::destroy()
         return;
     Q_D(QOpenGLTextureBlitter);
     d->programs[QOpenGLTextureBlitterPrivate::TEXTURE_2D].glProgram.reset();
+    d->programs[QOpenGLTextureBlitterPrivate::TEXTURE_2D_SRGB_TO_SCRGB].glProgram.reset();
+    d->programs[QOpenGLTextureBlitterPrivate::TEXTURE_2D_SRGB_TO_BT2020PQ].glProgram.reset();
     d->programs[QOpenGLTextureBlitterPrivate::TEXTURE_EXTERNAL_OES].glProgram.reset();
     d->vertexBuffer.destroy();
     d->textureBuffer.destroy();
@@ -484,15 +640,26 @@ bool QOpenGLTextureBlitter::supportsExternalOESTarget() const
 
     \sa release(), blit()
  */
-void QOpenGLTextureBlitter::bind(GLenum target)
+void QOpenGLTextureBlitter::bind(GLenum target,
+                                 QSurfaceFormat::ColorSpace srcColorSpace,
+                                 QSurfaceFormat::ColorSpace dstColorSpace)
 {
     Q_D(QOpenGLTextureBlitter);
 
     if (d->vao->isCreated())
         d->vao->bind();
 
+    const int index = d->calcColorSpaceConversionIndex(srcColorSpace, dstColorSpace);
+
+    if (index >= 0) {
+        d->colorSpaceConversion = index;
+    } else {
+        qWarning() << "QOpenGLTextureBlitter::bind(): color space conversion is not supported" << srcColorSpace << dstColorSpace;
+        d->colorSpaceConversion = 0; // noop conversion
+    }
+
     d->currentTarget = target;
-    QOpenGLTextureBlitterPrivate::Program *p = &d->programs[targetToProgramIndex(target)];
+    QOpenGLTextureBlitterPrivate::Program *p = &d->programs[targetToProgramIndex(target, d->colorSpaceConversion)];
     p->glProgram->bind();
 
     d->vertexBuffer.bind();
@@ -506,6 +673,21 @@ void QOpenGLTextureBlitter::bind(GLenum target)
     d->textureBuffer.release();
 }
 
+void QOpenGLTextureBlitter::rebind(GLenum target, QSurfaceFormat::ColorSpace srcColorSpace, QSurfaceFormat::ColorSpace dstColorSpace)
+{
+    Q_D(QOpenGLTextureBlitter);
+
+    if (d->vao->isCreated() &&
+        d->currentTarget == target &&
+        d->colorSpaceConversion == d->calcColorSpaceConversionIndex(srcColorSpace, dstColorSpace)) {
+
+        // the blitter is already configured in the correct state, so just skip it
+        return;
+    }
+
+    bind(target, srcColorSpace, dstColorSpace);
+}
+
 /*!
     Unbinds the graphics resources used by the blitter.
 
@@ -514,7 +696,7 @@ void QOpenGLTextureBlitter::bind(GLenum target)
 void QOpenGLTextureBlitter::release()
 {
     Q_D(QOpenGLTextureBlitter);
-    d->programs[targetToProgramIndex(d->currentTarget)].glProgram->release();
+    d->programs[targetToProgramIndex(d->currentTarget, d->colorSpaceConversion)].glProgram->release();
     if (d->vao->isCreated())
         d->vao->release();
 }
diff --git a/src/gui/opengl/qopengltextureblitter.h b/src/gui/opengl/qopengltextureblitter.h
index 2f7c6b1a..3c87e4e2 100644
--- a/src/gui/opengl/qopengltextureblitter.h
+++ b/src/gui/opengl/qopengltextureblitter.h
@@ -48,6 +48,9 @@
 #include <QtGui/QMatrix3x3>
 #include <QtGui/QMatrix4x4>
 
+// TODO: less includes!!!
+#include <QSurfaceFormat>
+
 QT_BEGIN_NAMESPACE
 
 class QOpenGLTextureBlitterPrivate;
@@ -69,7 +72,14 @@ public:
 
     bool supportsExternalOESTarget() const;
 
-    void bind(GLenum target = GL_TEXTURE_2D);
+    void bind(GLenum target = GL_TEXTURE_2D,
+              QSurfaceFormat::ColorSpace srcColorSpace = QSurfaceFormat::DefaultColorSpace,
+              QSurfaceFormat::ColorSpace dstColorSpace = QSurfaceFormat::DefaultColorSpace);
+
+    void rebind(GLenum target = GL_TEXTURE_2D,
+                QSurfaceFormat::ColorSpace srcColorSpace = QSurfaceFormat::DefaultColorSpace,
+                QSurfaceFormat::ColorSpace dstColorSpace = QSurfaceFormat::DefaultColorSpace);
+
     void release();
 
     void setRedBlueSwizzle(bool swizzle);
diff --git a/src/gui/painting/qplatformbackingstore.cpp b/src/gui/painting/qplatformbackingstore.cpp
index c71d8254..8dd96a66 100644
--- a/src/gui/painting/qplatformbackingstore.cpp
+++ b/src/gui/painting/qplatformbackingstore.cpp
@@ -132,6 +132,7 @@ struct QBackingstoreTextureInfo
     QRect rect;
     QRect clipRect;
     QPlatformTextureList::Flags flags;
+    QSurfaceFormat::ColorSpace colorSpace;
 };
 
 Q_DECLARE_TYPEINFO(QBackingstoreTextureInfo, Q_MOVABLE_TYPE);
@@ -181,6 +182,12 @@ QPlatformTextureList::Flags QPlatformTextureList::flags(int index) const
     return d->textures.at(index).flags;
 }
 
+QSurfaceFormat::ColorSpace QPlatformTextureList::colorSpace(int index) const
+{
+    Q_D(const QPlatformTextureList);
+    return d->textures.at(index).colorSpace;
+}
+
 QRect QPlatformTextureList::geometry(int index) const
 {
     Q_D(const QPlatformTextureList);
@@ -209,7 +216,7 @@ bool QPlatformTextureList::isLocked() const
 }
 
 void QPlatformTextureList::appendTexture(void *source, GLuint textureId, const QRect &geometry,
-                                         const QRect &clipRect, Flags flags)
+                                         const QRect &clipRect, Flags flags, QSurfaceFormat::ColorSpace colorSpace)
 {
     Q_D(QPlatformTextureList);
     QBackingstoreTextureInfo bi;
@@ -218,6 +225,7 @@ void QPlatformTextureList::appendTexture(void *source, GLuint textureId, const Q
     bi.rect = geometry;
     bi.clipRect = clipRect;
     bi.flags = flags;
+    bi.colorSpace = colorSpace;
     d->textures.append(bi);
 }
 
@@ -300,6 +308,7 @@ static void blitTextureForWidget(const QPlatformTextureList *textures, int idx,
     if (srgb && canUseSrgb)
         funcs->glEnable(GL_FRAMEBUFFER_SRGB);
 
+    blitter->rebind(GL_TEXTURE_2D, textures->colorSpace(idx), window->format().colorSpace());
     blitter->blit(textures->textureId(idx), target, source);
 
     if (srgb && canUseSrgb)
@@ -433,6 +442,11 @@ void QPlatformBackingStore::composeAndFlush(QWindow *window, const QRegion &regi
         funcs->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE);
 
     if (textureId) {
+        // GUI texture is always in sRGB color space
+        d_ptr->blitter->rebind(GL_TEXTURE_2D,
+                               QSurfaceFormat::sRGBColorSpace,
+                               window->format().colorSpace());
+
         if (d_ptr->needsSwizzle)
             d_ptr->blitter->setRedBlueSwizzle(true);
         // The backingstore is for the entire tlw.
diff --git a/src/gui/painting/qplatformbackingstore.h b/src/gui/painting/qplatformbackingstore.h
index de5ba964..f8887bd4 100644
--- a/src/gui/painting/qplatformbackingstore.h
+++ b/src/gui/painting/qplatformbackingstore.h
@@ -95,11 +95,13 @@ public:
     QRect clipRect(int index) const;
     void *source(int index);
     Flags flags(int index) const;
+    QSurfaceFormat::ColorSpace colorSpace(int index) const;
     void lock(bool on);
     bool isLocked() const;
 
     void appendTexture(void *source, GLuint textureId, const QRect &geometry,
-                       const QRect &clipRect = QRect(), Flags flags = 0);
+                       const QRect &clipRect = QRect(), Flags flags = 0,
+                       QSurfaceFormat::ColorSpace colorSpace = QSurfaceFormat::DefaultColorSpace);
     void clear();
 
  Q_SIGNALS:
diff --git a/src/platformsupport/platformcompositor/qopenglcompositorbackingstore.cpp b/src/platformsupport/platformcompositor/qopenglcompositorbackingstore.cpp
index 40400e2a..5d44e624 100644
--- a/src/platformsupport/platformcompositor/qopenglcompositorbackingstore.cpp
+++ b/src/platformsupport/platformcompositor/qopenglcompositorbackingstore.cpp
@@ -230,7 +230,7 @@ void QOpenGLCompositorBackingStore::composeAndFlush(QWindow *window, const QRegi
     m_textures->clear();
     for (int i = 0; i < textures->count(); ++i)
         m_textures->appendTexture(textures->source(i), textures->textureId(i), textures->geometry(i),
-                                  textures->clipRect(i), textures->flags(i));
+                                  textures->clipRect(i), textures->flags(i), textures->colorSpace(i));
 
     updateTexture();
     m_textures->appendTexture(nullptr, m_bsTexture, window->geometry());
diff --git a/src/widgets/kernel/qopenglwidget.cpp b/src/widgets/kernel/qopenglwidget.cpp
index 89f86015..0abf707e 100644
--- a/src/widgets/kernel/qopenglwidget.cpp
+++ b/src/widgets/kernel/qopenglwidget.cpp
@@ -568,7 +568,8 @@ public:
           updateBehavior(QOpenGLWidget::NoPartialUpdate),
           requestedSamples(0),
           inPaintGL(false),
-          textureFormat(0)
+          textureFormat(0),
+          textureColorSpace(QSurfaceFormat::DefaultColorSpace)
     {
         requestedFormat = QSurfaceFormat::defaultFormat();
     }
@@ -578,6 +579,7 @@ public:
 
     GLuint textureId() const override;
     QPlatformTextureList::Flags textureListFlags() override;
+    QSurfaceFormat::ColorSpace colorSpace() const override;
 
     void initialize();
     void invokeUserPaint();
@@ -609,6 +611,7 @@ public:
     int requestedSamples;
     bool inPaintGL;
     GLenum textureFormat;
+    QSurfaceFormat::ColorSpace textureColorSpace;
 };
 
 void QOpenGLWidgetPaintDevicePrivate::beginPaint()
@@ -695,6 +698,11 @@ QPlatformTextureList::Flags QOpenGLWidgetPrivate::textureListFlags()
     return flags;
 }
 
+QSurfaceFormat::ColorSpace QOpenGLWidgetPrivate::colorSpace() const
+{
+    return textureColorSpace;
+}
+
 void QOpenGLWidgetPrivate::reset()
 {
     Q_Q(QOpenGLWidget);
@@ -1115,6 +1123,41 @@ void QOpenGLWidget::setTextureFormat(GLenum texFormat)
     d->textureFormat = texFormat;
 }
 
+/*!
+    \return the declared color space of the internal texture of the widget.
+
+    The texture's color space will be used when composing the widget
+    into the root window surface.
+
+    \note when the color space is set to QSurfaceFormat::DefaultColorSpace,
+    color conversion is effectively disabled.
+
+    \since 5.99
+ */
+QSurfaceFormat::ColorSpace QOpenGLWidget::textureColorSpace() const
+{
+    Q_D(const QOpenGLWidget);
+    return d->textureColorSpace;
+}
+
+/*!
+    Sets a custom color space for the internal texture of the widget
+
+    The color space of the texture will be compared against the color
+    space of the root surface and conversion will be performed if needed.
+
+    \note setting the color space to QSurfaceFormat::DefaultColorSpace will
+    effectively disable color conversion when composing this texture on
+    screen.
+
+    \since 5.99
+ */
+void QOpenGLWidget::setTextureColorSpace(QSurfaceFormat::ColorSpace colorSpace)
+{
+    Q_D(QOpenGLWidget);
+    d->textureColorSpace = colorSpace;
+}
+
 /*!
     \return the active internal texture format if the widget has already
     initialized, the requested format if one was set but the widget has not yet
diff --git a/src/widgets/kernel/qopenglwidget.h b/src/widgets/kernel/qopenglwidget.h
index 9eb4a9ba..eff2d979 100644
--- a/src/widgets/kernel/qopenglwidget.h
+++ b/src/widgets/kernel/qopenglwidget.h
@@ -75,6 +75,9 @@ public:
     GLenum textureFormat() const;
     void setTextureFormat(GLenum texFormat);
 
+    QSurfaceFormat::ColorSpace textureColorSpace() const;
+    void setTextureColorSpace(QSurfaceFormat::ColorSpace colorSpace);
+
     bool isValid() const;
 
     void makeCurrent();
diff --git a/src/widgets/kernel/qwidget_p.h b/src/widgets/kernel/qwidget_p.h
index 7e4ea2cc..1ff5af42 100644
--- a/src/widgets/kernel/qwidget_p.h
+++ b/src/widgets/kernel/qwidget_p.h
@@ -655,6 +655,7 @@ public:
             ? QPlatformTextureList::StacksOnTop
             : QPlatformTextureList::Flags(0);
     }
+    virtual QSurfaceFormat::ColorSpace colorSpace() const { return QSurfaceFormat::DefaultColorSpace; }
     virtual QImage grabFramebuffer() { return QImage(); }
     virtual void beginBackingStorePainting() { }
     virtual void endBackingStorePainting() { }
diff --git a/src/widgets/kernel/qwidgetbackingstore.cpp b/src/widgets/kernel/qwidgetbackingstore.cpp
index a32eb2a0..db603380 100644
--- a/src/widgets/kernel/qwidgetbackingstore.cpp
+++ b/src/widgets/kernel/qwidgetbackingstore.cpp
@@ -1007,7 +1007,7 @@ static void findTextureWidgetsRecursively(QWidget *tlw, QWidget *widget, QPlatfo
     if (wd->renderToTexture) {
         QPlatformTextureList::Flags flags = wd->textureListFlags();
         const QRect rect(widget->mapTo(tlw, QPoint()), widget->size());
-        widgetTextures->appendTexture(widget, wd->textureId(), rect, wd->clipRect(), flags);
+        widgetTextures->appendTexture(widget, wd->textureId(), rect, wd->clipRect(), flags, wd->colorSpace());
     }
 
     for (int i = 0; i < wd->children.size(); ++i) {
-- 
2.22.0.windows.1

From cd8298f8ed3735396d9274a629df3664298d7554 Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Tue, 4 Dec 2018 20:11:34 +0300
Subject: [PATCH 07/27] Return QScreen's HMONITOR handle via
 QPlatformNativeInterface

It is needed to be able to fetch extra information about the display via
DXGI interface.

Change-Id: Id83982eb07ade157719e430d0abcc2613409a343
---
 .../windows/qwindowsnativeinterface.cpp          | 16 ++++++++++++++++
 .../platforms/windows/qwindowsnativeinterface.h  |  1 +
 src/plugins/platforms/windows/qwindowsscreen.cpp |  5 +++++
 src/plugins/platforms/windows/qwindowsscreen.h   |  2 ++
 4 files changed, 24 insertions(+)

diff --git a/src/plugins/platforms/windows/qwindowsnativeinterface.cpp b/src/plugins/platforms/windows/qwindowsnativeinterface.cpp
index ed945ec4..1c5be441 100644
--- a/src/plugins/platforms/windows/qwindowsnativeinterface.cpp
+++ b/src/plugins/platforms/windows/qwindowsnativeinterface.cpp
@@ -40,6 +40,7 @@
 #include "qwindowsnativeinterface.h"
 #include "qwindowsclipboard.h"
 #include "qwindowswindow.h"
+#include "qwindowsscreen.h"
 #include "qwindowscontext.h"
 #include "qwindowscursor.h"
 #include "qwindowsopenglcontext.h"
@@ -124,6 +125,21 @@ void *QWindowsNativeInterface::nativeResourceForWindow(const QByteArray &resourc
     return nullptr;
 }
 
+void *QWindowsNativeInterface::nativeResourceForScreen(const QByteArray &resource, QScreen *screen)
+{
+    if (!screen || !screen->handle()) {
+        qWarning("%s: '%s' requested for null screen or screen without handle.", __FUNCTION__, resource.constData());
+        return 0;
+    }
+    QWindowsScreen *bs = static_cast<QWindowsScreen *>(screen->handle());
+    int type = resourceType(resource);
+    if (type == HandleType)
+        return bs->handle();
+
+    qWarning("%s: Invalid key '%s' requested.", __FUNCTION__, resource.constData());
+    return 0;
+}
+
 #ifndef QT_NO_CURSOR
 void *QWindowsNativeInterface::nativeResourceForCursor(const QByteArray &resource, const QCursor &cursor)
 {
diff --git a/src/plugins/platforms/windows/qwindowsnativeinterface.h b/src/plugins/platforms/windows/qwindowsnativeinterface.h
index e6f8aae8..ce395dc5 100644
--- a/src/plugins/platforms/windows/qwindowsnativeinterface.h
+++ b/src/plugins/platforms/windows/qwindowsnativeinterface.h
@@ -74,6 +74,7 @@ public:
     void *nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context) override;
 #endif
     void *nativeResourceForWindow(const QByteArray &resource, QWindow *window) override;
+    void *nativeResourceForScreen(const QByteArray &resource, QScreen *screen) override;
 #ifndef QT_NO_CURSOR
     void *nativeResourceForCursor(const QByteArray &resource, const QCursor &cursor) override;
 #endif
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index 0520f889..b70b0bbe 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -321,6 +321,11 @@ void QWindowsScreen::handleChanges(const QWindowsScreenData &newData)
     }
 }
 
+HMONITOR QWindowsScreen::handle() const
+{
+    return m_data.hMonitor;
+}
+
 QRect QWindowsScreen::virtualGeometry(const QPlatformScreen *screen) // cf QScreen::virtualGeometry()
 {
     QRect result;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.h b/src/plugins/platforms/windows/qwindowsscreen.h
index 824bcb1a..33c9effa 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.h
+++ b/src/plugins/platforms/windows/qwindowsscreen.h
@@ -104,6 +104,8 @@ public:
 
     inline void handleChanges(const QWindowsScreenData &newData);
 
+    HMONITOR handle() const;
+
 #ifndef QT_NO_CURSOR
     QPlatformCursor *cursor() const override { return m_cursor.data(); }
     const CursorPtr &cursorPtr() const { return m_cursor; }
-- 
2.22.0.windows.1

From f8cf8c0cf6bde2e81a31b3fabd4c435c87d10b1d Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Sun, 10 Feb 2019 22:55:59 +0300
Subject: [PATCH 08/27] Implement a manual test for checking is HDR features
 work

Test plan:

1) Run without arguments: `hdr-openglwidget.exe`
   It should show you three rectangles: the left one should be HDR'ly
   bright, the other ones should be SDR'ly dim and look exactly the same.

3) Run in Bt. 2020 PQ mode: `hdr-openglwidget.exe --bt2020pq`
   The result should look exactly the same.

4) Run in SDR sRGB mode: `hdr-openglwidget.exe --srgb`.
   All three images should look SDR'ly dim.

NOTE:
Please note that the current implementation of SDR compositing
in QOpenGLTextureBlitter doesn't support user configuration for
SDR brightness from the system. This API is available for UWP
applications only. It means that when changing "SDR brightness"
slider in Windows' settings, the brightness of our SDR widget
will not change. More that that, it might even be different from
the brightness of other SDR applications.

Change-Id: Idccc790937c9061ec618ab21f6b71bd0620cd2cc
---
 .../hdr-qopenglwidget/KisGLImageF16.cpp       | 131 +++++++++
 .../manual/hdr-qopenglwidget/KisGLImageF16.h  |  68 +++++
 .../hdr-qopenglwidget/KisGLImageWidget.cpp    | 252 ++++++++++++++++++
 .../hdr-qopenglwidget/KisGLImageWidget.h      |  77 ++++++
 .../hdr-qopenglwidget/hdr-openglwidget.pro    |  20 ++
 .../kis_gl_image_widget.frag                  |  23 ++
 .../hdr-qopenglwidget/kis_gl_image_widget.qrc |   6 +
 .../kis_gl_image_widget.vert                  |  17 ++
 tests/manual/hdr-qopenglwidget/main.cpp       | 153 +++++++++++
 .../hdr-qopenglwidget/openglprobeutils.cpp    | 139 ++++++++++
 .../hdr-qopenglwidget/openglprobeutils.h      |  42 +++
 tests/manual/hdr-qopenglwidget/window.cpp     | 219 +++++++++++++++
 tests/manual/hdr-qopenglwidget/window.h       |  69 +++++
 tests/manual/manual.pro                       |   2 +-
 14 files changed, 1217 insertions(+), 1 deletion(-)
 create mode 100644 tests/manual/hdr-qopenglwidget/KisGLImageF16.cpp
 create mode 100644 tests/manual/hdr-qopenglwidget/KisGLImageF16.h
 create mode 100644 tests/manual/hdr-qopenglwidget/KisGLImageWidget.cpp
 create mode 100644 tests/manual/hdr-qopenglwidget/KisGLImageWidget.h
 create mode 100644 tests/manual/hdr-qopenglwidget/hdr-openglwidget.pro
 create mode 100644 tests/manual/hdr-qopenglwidget/kis_gl_image_widget.frag
 create mode 100644 tests/manual/hdr-qopenglwidget/kis_gl_image_widget.qrc
 create mode 100644 tests/manual/hdr-qopenglwidget/kis_gl_image_widget.vert
 create mode 100644 tests/manual/hdr-qopenglwidget/main.cpp
 create mode 100644 tests/manual/hdr-qopenglwidget/openglprobeutils.cpp
 create mode 100644 tests/manual/hdr-qopenglwidget/openglprobeutils.h
 create mode 100644 tests/manual/hdr-qopenglwidget/window.cpp
 create mode 100644 tests/manual/hdr-qopenglwidget/window.h

diff --git a/tests/manual/hdr-qopenglwidget/KisGLImageF16.cpp b/tests/manual/hdr-qopenglwidget/KisGLImageF16.cpp
new file mode 100644
index 00000000..a84b676f
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/KisGLImageF16.cpp
@@ -0,0 +1,131 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "KisGLImageF16.h"
+
+#include <QByteArray>
+#include <QSize>
+
+struct KisGLImageF16::Private : public QSharedData
+{
+    QSize size;
+    QByteArray data;
+};
+
+KisGLImageF16::KisGLImageF16()
+    : m_d(new Private)
+{
+}
+
+KisGLImageF16::KisGLImageF16(const QSize &size, bool clearPixels)
+    : m_d(new Private)
+{
+    resize(size, clearPixels);
+}
+
+KisGLImageF16::KisGLImageF16(int width, int height, bool clearPixels)
+    : KisGLImageF16(QSize(width, height), clearPixels)
+{
+}
+
+KisGLImageF16::KisGLImageF16(const KisGLImageF16 &rhs)
+    : m_d(rhs.m_d)
+{
+}
+
+KisGLImageF16 &KisGLImageF16::operator=(const KisGLImageF16 &rhs)
+{
+    m_d = rhs.m_d;
+}
+
+bool operator==(const KisGLImageF16 &lhs, const KisGLImageF16 &rhs)
+{
+    return lhs.m_d == rhs.m_d;
+}
+
+bool operator!=(const KisGLImageF16 &lhs, const KisGLImageF16 &rhs)
+{
+    return !(lhs == rhs);
+}
+
+KisGLImageF16::~KisGLImageF16()
+{
+}
+
+void KisGLImageF16::clearPixels()
+{
+    if (!m_d->data.isEmpty()) {
+        m_d->data.fill(0);
+    }
+}
+
+void KisGLImageF16::resize(const QSize &size, bool clearPixels)
+{
+    const int pixelSize = 2 * 4;
+
+    m_d->size = size;
+    m_d->data.resize(size.width() * size.height() * pixelSize);
+
+    if (clearPixels) {
+        m_d->data.fill(0);
+    }
+}
+
+const qfloat16 *KisGLImageF16::constData() const
+{
+    Q_ASSERT(!m_d->data.isNull());
+    return reinterpret_cast<const qfloat16*>(m_d->data.data());
+}
+
+qfloat16 *KisGLImageF16::data()
+{
+    m_d->data.detach();
+    Q_ASSERT(!m_d->data.isNull());
+
+    return reinterpret_cast<qfloat16*>(m_d->data.data());
+}
+
+QSize KisGLImageF16::size() const
+{
+    return m_d->size;
+}
+
+int KisGLImageF16::width() const
+{
+    return m_d->size.width();
+}
+
+int KisGLImageF16::height() const
+{
+    return m_d->size.height();
+}
+
+bool KisGLImageF16::isNull() const
+{
+    return m_d->data.isNull();
+}
diff --git a/tests/manual/hdr-qopenglwidget/KisGLImageF16.h b/tests/manual/hdr-qopenglwidget/KisGLImageF16.h
new file mode 100644
index 00000000..335e42ee
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/KisGLImageF16.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef KISGLIMAGEF16_H
+#define KISGLIMAGEF16_H
+
+#include <QSharedDataPointer>
+#include <QFloat16>
+
+class QSize;
+
+class KisGLImageF16
+{
+public:
+    KisGLImageF16();
+    KisGLImageF16(const QSize &size, bool clearPixels = false);
+    KisGLImageF16(int width, int height, bool clearPixels = false);
+    KisGLImageF16(const KisGLImageF16 &rhs);
+    KisGLImageF16& operator=(const KisGLImageF16 &rhs);
+
+    friend bool operator==(const KisGLImageF16 &lhs, const KisGLImageF16 &rhs);
+    friend bool operator!=(const KisGLImageF16 &lhs, const KisGLImageF16 &rhs);
+
+    ~KisGLImageF16();
+
+    void clearPixels();
+    void resize(const QSize &size, bool clearPixels = false);
+
+    const qfloat16* constData() const;
+    qfloat16* data();
+
+    QSize size() const;
+    int width() const;
+    int height() const;
+
+    bool isNull() const;
+
+private:
+    struct Private;
+    QSharedDataPointer<Private> m_d;
+};
+
+#endif // KISGLIMAGEF16_H
diff --git a/tests/manual/hdr-qopenglwidget/KisGLImageWidget.cpp b/tests/manual/hdr-qopenglwidget/KisGLImageWidget.cpp
new file mode 100644
index 00000000..da36ac16
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/KisGLImageWidget.cpp
@@ -0,0 +1,252 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "KisGLImageWidget.h"
+
+#include <QPainter>
+#include <QFile>
+#include <QResizeEvent>
+
+#include "KisGLImageF16.h"
+
+namespace {
+inline void rectToVertices(QVector3D* vertices, const QRectF &rc)
+{
+    vertices[0] = QVector3D(rc.left(),  rc.bottom(), 0.f);
+    vertices[1] = QVector3D(rc.left(),  rc.top(),    0.f);
+    vertices[2] = QVector3D(rc.right(), rc.bottom(), 0.f);
+    vertices[3] = QVector3D(rc.left(),  rc.top(), 0.f);
+    vertices[4] = QVector3D(rc.right(), rc.top(), 0.f);
+    vertices[5] = QVector3D(rc.right(), rc.bottom(),    0.f);
+}
+
+inline void rectToTexCoords(QVector2D* texCoords, const QRectF &rc)
+{
+    texCoords[0] = QVector2D(rc.left(), rc.bottom());
+    texCoords[1] = QVector2D(rc.left(), rc.top());
+    texCoords[2] = QVector2D(rc.right(), rc.bottom());
+    texCoords[3] = QVector2D(rc.left(), rc.top());
+    texCoords[4] = QVector2D(rc.right(), rc.top());
+    texCoords[5] = QVector2D(rc.right(), rc.bottom());
+}
+}
+
+KisGLImageWidget::KisGLImageWidget(QWidget *parent)
+    : KisGLImageWidget(QSurfaceFormat::sRGBColorSpace, parent)
+{
+}
+
+KisGLImageWidget::KisGLImageWidget(QSurfaceFormat::ColorSpace colorSpace,
+                                   QWidget *parent)
+    : QOpenGLWidget(parent),
+      m_texture(QOpenGLTexture::Target2D)
+{
+
+    qDebug() << "Crating gl widget";
+
+    setTextureFormat(GL_RGBA16F);
+    setTextureColorSpace(colorSpace);
+
+    setUpdateBehavior(QOpenGLWidget::NoPartialUpdate);
+}
+
+void KisGLImageWidget::initializeGL()
+{
+    initializeOpenGLFunctions();
+
+    qDebug() << "Initialized with format:" << context()->format();
+
+    QFile vertexShaderFile(QString(":/") + "kis_gl_image_widget.vert");
+    vertexShaderFile.open(QIODevice::ReadOnly);
+    QString vertSource = vertexShaderFile.readAll();
+
+    QFile fragShaderFile(QString(":/") + "kis_gl_image_widget.frag");
+    fragShaderFile.open(QIODevice::ReadOnly);
+    QString fragSource = fragShaderFile.readAll();
+
+    if (context()->isOpenGLES()) {
+        const char *versionHelper = "#define USE_OPENGLES\n";
+        vertSource.prepend(versionHelper);
+        fragSource.prepend(versionHelper);
+
+        const char *versionDefinition = "#version 100\n";
+        vertSource.prepend(versionDefinition);
+        fragSource.prepend(versionDefinition);
+    } else {
+        const char *versionDefinition = "#version 330 core\n";
+        vertSource.prepend(versionDefinition);
+        fragSource.prepend(versionDefinition);
+    }
+
+    if (!m_shader.addShaderFromSourceCode(QOpenGLShader::Vertex, vertSource)) {
+        qDebug() << "Could not add vertex code";
+        return;
+    }
+
+    if (!m_shader.addShaderFromSourceCode(QOpenGLShader::Fragment, fragSource)) {
+        qDebug() << "Could not add fragment code";
+        return;
+    }
+
+    if (!m_shader.link()) {
+        qDebug() << "Could not link";
+        return;
+    }
+
+    if (!m_shader.bind()) {
+        qDebug() << "Could not bind";
+        return;
+    }
+
+    m_shader.release();
+
+
+    m_vao.create();
+    m_vao.bind();
+
+    m_verticesBuffer.create();
+    updateVerticesBuffer(this->rect());
+
+    QVector<QVector2D> textureVertices(6);
+    rectToTexCoords(textureVertices.data(), QRect(0.0, 0.0, 1.0, 1.0));
+
+    m_textureVerticesBuffer.create();
+    m_textureVerticesBuffer.bind();
+    m_textureVerticesBuffer.setUsagePattern(QOpenGLBuffer::DynamicDraw);
+    m_textureVerticesBuffer.allocate(2 * 3 * sizeof(QVector2D));
+    m_verticesBuffer.write(0, textureVertices.data(), m_textureVerticesBuffer.size());
+    m_textureVerticesBuffer.release();
+
+    m_vao.release();
+
+
+    if (!m_sourceImage.isNull()) {
+        loadImage(m_sourceImage);
+    }
+}
+
+void KisGLImageWidget::updateVerticesBuffer(const QRect &rect)
+{
+    if (!m_vao.isCreated() || !m_verticesBuffer.isCreated()) return;
+
+    QVector<QVector3D> vertices(6);
+    rectToVertices(vertices.data(), rect);
+
+    m_verticesBuffer.bind();
+    m_verticesBuffer.setUsagePattern(QOpenGLBuffer::DynamicDraw);
+    m_verticesBuffer.allocate(2 * 3 * sizeof(QVector3D));
+    m_verticesBuffer.write(0, vertices.data(), m_verticesBuffer.size());
+    m_verticesBuffer.release();
+}
+
+
+void KisGLImageWidget::paintGL()
+{
+    const QColor bgColor = palette().background().color();
+    glClearColor(bgColor.redF(), bgColor.greenF(), bgColor.blueF(), 1.0f);
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    if (!m_texture.isCreated()) return;
+
+    glViewport(0, 0, width(), height());
+
+    m_vao.bind();
+    m_shader.bind();
+
+    {
+        QMatrix4x4 projectionMatrix;
+        projectionMatrix.setToIdentity();
+        projectionMatrix.ortho(0, width(), height(), 0, -1, 1);
+        QMatrix4x4 viewProjectionMatrix;
+
+        // use a QTransform to scale, translate, rotate your view
+        QTransform transform; // TODO: noop!
+        viewProjectionMatrix = projectionMatrix * QMatrix4x4(transform);
+
+        m_shader.setUniformValue("viewProjectionMatrix", viewProjectionMatrix);
+    }
+
+    m_shader.enableAttributeArray("vertexPosition");
+    m_verticesBuffer.bind();
+    m_shader.setAttributeBuffer("vertexPosition", GL_FLOAT, 0, 3);
+
+    m_shader.enableAttributeArray("texturePosition");
+    m_textureVerticesBuffer.bind();
+    m_shader.setAttributeBuffer("texturePosition", GL_FLOAT, 0, 2);
+
+    glActiveTexture(GL_TEXTURE0);
+    m_texture.bind();
+
+    // draw 2 triangles = 6 vertices starting at offset 0 in the buffer
+    glDrawArrays(GL_TRIANGLES, 0, 6);
+
+    m_verticesBuffer.release();
+    m_textureVerticesBuffer.release();
+    m_texture.release();
+    m_shader.release();
+    m_vao.release();
+}
+
+void KisGLImageWidget::loadImage(const KisGLImageF16 &image)
+{
+    if (m_sourceImage != image) {
+        m_sourceImage = image;
+    }
+
+    if (m_vao.isCreated()) {
+        m_texture.setFormat(QOpenGLTexture::RGBA16F);
+        m_texture.setSize(image.width(), image.height());
+        m_texture.allocateStorage(QOpenGLTexture::RGBA, QOpenGLTexture::Float16);
+        m_texture.setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);
+        m_texture.setMagnificationFilter(QOpenGLTexture::Linear);
+        m_texture.setData(QOpenGLTexture::RGBA, QOpenGLTexture::Float16, image.constData());
+        updateGeometry();
+    }
+}
+
+void KisGLImageWidget::paintEvent(QPaintEvent *event)
+{
+    QOpenGLWidget::paintEvent(event);
+}
+
+void KisGLImageWidget::resizeEvent(QResizeEvent *event)
+{
+    updateVerticesBuffer(QRect(QPoint(),event->size()));
+    QOpenGLWidget::resizeEvent(event);
+}
+
+QSize KisGLImageWidget::sizeHint() const
+{
+    return m_sourceImage.size();
+}
+
+KisGLImageF16 KisGLImageWidget::image() const
+{
+    return m_sourceImage;
+}
+
diff --git a/tests/manual/hdr-qopenglwidget/KisGLImageWidget.h b/tests/manual/hdr-qopenglwidget/KisGLImageWidget.h
new file mode 100644
index 00000000..e807064c
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/KisGLImageWidget.h
@@ -0,0 +1,77 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef KISGLIMAGEWIDGET_H
+#define KISGLIMAGEWIDGET_H
+
+#include <QOpenGLWidget>
+#include <QOpenGLFunctions>
+#include <QOpenGLTexture>
+#include <QOpenGLShaderProgram>
+#include <QOpenGLVertexArrayObject>
+#include <QOpenGLBuffer>
+#include <QTransform>
+#include <KisGLImageF16.h>
+
+
+class KisGLImageWidget : public QOpenGLWidget, protected QOpenGLFunctions
+{
+    Q_OBJECT
+public:
+    KisGLImageWidget(QWidget *parent = nullptr);
+    KisGLImageWidget(QSurfaceFormat::ColorSpace colorSpace,
+                     QWidget *parent = nullptr);
+
+    void initializeGL() override;
+    void paintGL() override;
+
+    void loadImage(const KisGLImageF16 &image);
+
+    void paintEvent(QPaintEvent *event) override;
+    void resizeEvent(QResizeEvent *event) override;
+
+    QSize sizeHint() const override;
+
+    KisGLImageF16 image() const;
+
+public Q_SLOTS:
+
+private:
+    void updateVerticesBuffer(const QRect &rect);
+
+private:
+    KisGLImageF16 m_sourceImage;
+
+    QOpenGLShaderProgram m_shader;
+    QOpenGLVertexArrayObject m_vao;
+    QOpenGLBuffer m_verticesBuffer;
+    QOpenGLBuffer m_textureVerticesBuffer;
+    QOpenGLTexture m_texture;
+};
+
+#endif // KISGLIMAGEWIDGET_H
diff --git a/tests/manual/hdr-qopenglwidget/hdr-openglwidget.pro b/tests/manual/hdr-qopenglwidget/hdr-openglwidget.pro
new file mode 100644
index 00000000..b418e54b
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/hdr-openglwidget.pro
@@ -0,0 +1,20 @@
+QT += widgets widgets-private gui-private core-private
+
+TARGET = hdr-openglwidget
+TEMPLATE = app
+
+SOURCES += main.cpp \
+        #hdr-openglwidget.cpp \
+        openglprobeutils.cpp \
+        KisGLImageWidget.cpp \
+        KisGLImageF16.cpp \
+        window.cpp
+
+HEADERS  += \
+#hdr-openglwidget.h \
+    openglprobeutils.h \
+    KisGLImageWidget.h \
+    KisGLImageF16.h \
+    window.h
+
+RESOURCES += kis_gl_image_widget.qrc
diff --git a/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.frag b/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.frag
new file mode 100644
index 00000000..b57c6570
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.frag
@@ -0,0 +1,23 @@
+#ifndef USE_OPENGLES
+#define INATTR in
+#define OUTATTR out
+#define DECLARE_OUT_VAR out vec4 f_fragColor;
+#define OUT_VAR f_fragColor
+#define highp
+#define texture2D texture
+#else
+#define INATTR varying
+#define DECLARE_OUT_VAR
+#define OUT_VAR gl_FragColor
+#endif
+// vertices data
+INATTR highp vec4 textureCoordinates;
+uniform sampler2D f_tileTexture;
+DECLARE_OUT_VAR
+
+void main()
+{
+    // get the fragment color from the tile texture
+    highp vec4 color = texture2D(f_tileTexture, textureCoordinates.st);
+    OUT_VAR = vec4(color);
+}
diff --git a/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.qrc b/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.qrc
new file mode 100644
index 00000000..ab5b5719
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.qrc
@@ -0,0 +1,6 @@
+<RCC>
+    <qresource prefix="/">
+        <file>kis_gl_image_widget.frag</file>
+        <file>kis_gl_image_widget.vert</file>
+    </qresource>
+</RCC>
diff --git a/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.vert b/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.vert
new file mode 100644
index 00000000..9578f479
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/kis_gl_image_widget.vert
@@ -0,0 +1,17 @@
+#ifndef USE_OPENGLES
+#define INATTR in
+#define OUTATTR out
+#define highp
+#else
+#define INATTR attribute
+#define OUTATTR varying
+#endif
+uniform mat4 viewProjectionMatrix;
+INATTR highp vec3 vertexPosition;
+INATTR highp vec2 texturePosition;
+OUTATTR highp vec4 textureCoordinates;
+void main()
+{
+   textureCoordinates = vec4(texturePosition.x, texturePosition.y, 0.0, 1.0);
+   gl_Position = viewProjectionMatrix * vec4(vertexPosition.x, vertexPosition.y, 0.0, 1.0);
+}
diff --git a/tests/manual/hdr-qopenglwidget/main.cpp b/tests/manual/hdr-qopenglwidget/main.cpp
new file mode 100644
index 00000000..e517ef85
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/main.cpp
@@ -0,0 +1,153 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QApplication>
+#include "window.h"
+
+#include "openglprobeutils.h"
+#include <QDebug>
+
+QSurfaceFormat generateSurfaceFormat(QSurfaceFormat::RenderableType renderer,
+                                     QSurfaceFormat::ColorSpace colorSpace,
+                                     int bitDepth)
+{
+    QSurfaceFormat format;
+#ifdef Q_OS_MACOS
+    format.setVersion(3, 2);
+    format.setProfile(QSurfaceFormat::CoreProfile);
+#else
+    format.setVersion(3, 0);
+    format.setProfile(QSurfaceFormat::CoreProfile);
+#endif
+    format.setDepthBufferSize(24);
+    format.setStencilBufferSize(8);
+
+    switch (bitDepth) {
+    case 8:
+        format.setRedBufferSize(8);
+        format.setGreenBufferSize(8);
+        format.setBlueBufferSize(8);
+        format.setAlphaBufferSize(8);
+        break;
+    case 10:
+        format.setRedBufferSize(10);
+        format.setGreenBufferSize(10);
+        format.setBlueBufferSize(10);
+        format.setAlphaBufferSize(2);
+        break;
+    case 16:
+        format.setRedBufferSize(16);
+        format.setGreenBufferSize(16);
+        format.setBlueBufferSize(16);
+        format.setAlphaBufferSize(16);
+        break;
+    default:
+        qFatal("Unsupported surface bit depth %d", bitDepth);
+    }
+
+    format.setRenderableType(renderer);
+    format.setColorSpace(colorSpace);
+
+    format.setSwapBehavior(QSurfaceFormat::DoubleBuffer);
+    format.setSwapInterval(0); // Disable vertical refresh syncing
+
+    return format;
+}
+
+int main(int argc, char *argv[])
+{
+    QVector<QSurfaceFormat> allFormats;
+
+    QVector<QSurfaceFormat::RenderableType> availableRenderers;
+    availableRenderers << QSurfaceFormat::OpenGL;
+    availableRenderers << QSurfaceFormat::OpenGLES;
+
+    for (QSurfaceFormat::RenderableType renderer : availableRenderers) {
+        allFormats << generateSurfaceFormat(renderer, QSurfaceFormat::sRGBColorSpace, 8);
+        allFormats << generateSurfaceFormat(renderer, QSurfaceFormat::bt2020PQColorSpace, 8);
+        allFormats << generateSurfaceFormat(renderer, QSurfaceFormat::sRGBColorSpace, 10);
+        allFormats << generateSurfaceFormat(renderer, QSurfaceFormat::bt2020PQColorSpace, 10);
+        allFormats << generateSurfaceFormat(renderer, QSurfaceFormat::scRGBColorSpace, 16);
+    }
+
+    for (QSurfaceFormat format : allFormats) {
+        qDebug() << "Probing: " << format;
+        bool result = OpenGLProbeUtils::probeFormat(format, true);
+        qDebug() << "    result:" << result;
+    }
+
+
+    if (argc > 1 && !strcmp(argv[1], "--sharecontext")) {
+        qDebug("Requesting all contexts to share");
+        QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
+    }
+
+    QApplication a(argc, argv);
+
+    QSurfaceFormat::RenderableType renderer = QSurfaceFormat::OpenGLES;
+    QSurfaceFormat::ColorSpace colorSpace = QSurfaceFormat::scRGBColorSpace;
+    int bitDepth = 16;
+
+
+    if (QCoreApplication::arguments().contains(QLatin1String("--scrgb"))) {
+        colorSpace = QSurfaceFormat::scRGBColorSpace;
+        bitDepth = 16;
+    } else if (QCoreApplication::arguments().contains(QLatin1String("--bt2020pq"))) {
+        colorSpace = QSurfaceFormat::bt2020PQColorSpace;
+        bitDepth = 10;
+    } else if (QCoreApplication::arguments().contains(QLatin1String("--srgb"))) {
+        colorSpace = QSurfaceFormat::sRGBColorSpace;
+        bitDepth = 8;
+    }
+
+    if (QCoreApplication::arguments().contains(QLatin1String("--opengl"))) {
+        renderer = QSurfaceFormat::OpenGL;
+    } else if (QCoreApplication::arguments().contains(QLatin1String("--opengles"))) {
+        renderer = QSurfaceFormat::OpenGLES;
+    }
+
+    QSurfaceFormat format = generateSurfaceFormat(renderer, colorSpace, bitDepth);
+
+    if (QCoreApplication::arguments().contains(QLatin1String("--multisample"))) {
+        format.setSamples(4);
+    }
+
+    if (format.renderableType() == QSurfaceFormat::OpenGL) {
+        QCoreApplication::setAttribute(Qt::AA_UseDesktopOpenGL, true);
+    } else if (format.renderableType() == QSurfaceFormat::OpenGLES) {
+        QCoreApplication::setAttribute(Qt::AA_UseOpenGLES, true);
+    }
+
+    qDebug() << "Requesting" << format.renderableType() << format;
+    QSurfaceFormat::setDefaultFormat(format);
+
+    Window window;
+    window.show();
+
+    return a.exec();
+}
diff --git a/tests/manual/hdr-qopenglwidget/openglprobeutils.cpp b/tests/manual/hdr-qopenglwidget/openglprobeutils.cpp
new file mode 100644
index 00000000..687cc089
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/openglprobeutils.cpp
@@ -0,0 +1,139 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "openglprobeutils.h"
+
+#include <QApplication>
+#include <QSurfaceFormat>
+#include <QOpenGLContext>
+#include <QDebug>
+#include <QWindow>
+
+namespace OpenGLProbeUtils {
+
+namespace {
+
+struct AppAttributeSetter
+{
+    AppAttributeSetter(Qt::ApplicationAttribute attribute, bool useOpenGLES)
+        : m_attribute(attribute),
+          m_oldValue(QCoreApplication::testAttribute(attribute))
+    {
+        QCoreApplication::setAttribute(attribute, useOpenGLES);
+    }
+
+    ~AppAttributeSetter() {
+        QCoreApplication::setAttribute(m_attribute, m_oldValue);
+    }
+
+private:
+    Qt::ApplicationAttribute m_attribute;
+    bool m_oldValue = false;
+};
+
+struct SurfaceFormatSetter
+{
+    SurfaceFormatSetter(const QSurfaceFormat &format)
+        : m_oldFormat(QSurfaceFormat::defaultFormat())
+    {
+        QSurfaceFormat::setDefaultFormat(format);
+    }
+
+    ~SurfaceFormatSetter() {
+        QSurfaceFormat::setDefaultFormat(m_oldFormat);
+    }
+
+private:
+    QSurfaceFormat m_oldFormat;
+};
+
+}
+
+bool fuzzyCompareColorSpaces(const QSurfaceFormat::ColorSpace &lhs, const QSurfaceFormat::ColorSpace &rhs)
+{
+    return lhs == rhs ||
+        ((lhs == QSurfaceFormat::DefaultColorSpace ||
+          lhs == QSurfaceFormat::sRGBColorSpace) &&
+         (rhs == QSurfaceFormat::DefaultColorSpace ||
+          rhs == QSurfaceFormat::sRGBColorSpace));
+}
+
+bool probeFormat(const QSurfaceFormat &format, bool adjustGlobalState)
+{
+    QScopedPointer<AppAttributeSetter> sharedContextSetter;
+    QScopedPointer<AppAttributeSetter> glSetter;
+    QScopedPointer<AppAttributeSetter> glesSetter;
+    QScopedPointer<SurfaceFormatSetter> formatSetter;
+    QScopedPointer<QApplication> application;
+
+    if (adjustGlobalState) {
+        sharedContextSetter.reset(new AppAttributeSetter(Qt::AA_ShareOpenGLContexts, false));
+
+        if (format.renderableType() != QSurfaceFormat::DefaultRenderableType) {
+            glSetter.reset(new AppAttributeSetter(Qt::AA_UseDesktopOpenGL, format.renderableType() != QSurfaceFormat::OpenGLES));
+            glesSetter.reset(new AppAttributeSetter(Qt::AA_UseOpenGLES, format.renderableType() == QSurfaceFormat::OpenGLES));
+        }
+
+        formatSetter.reset(new SurfaceFormatSetter(format));
+
+        int argc = 1;
+        QByteArray data("krita");
+        char *argv = data.data();
+        application.reset(new QApplication(argc, &argv));
+    }
+
+    QWindow surface;
+    surface.setFormat(format);
+    surface.setSurfaceType(QSurface::OpenGLSurface);
+    surface.create();
+    QOpenGLContext context;
+    context.setFormat(format);
+
+
+    if (!context.create()) {
+        qCritical() << "OpenGL context cannot be created";
+        return false;
+    }
+    if (!context.isValid()) {
+        qCritical() << "OpenGL context is not valid while checking Qt's OpenGL status";
+        return false;
+    }
+    if (!context.makeCurrent(&surface)) {
+        qCritical() << "OpenGL context cannot be made current";
+        return false;
+    }
+
+    if (!fuzzyCompareColorSpaces(context.format().colorSpace(), format.colorSpace())) {
+        qCritical() << "Failed to create an OpenGL context with requested color space. Requested:" << format.colorSpace() << "Actual:" << context.format().colorSpace();
+        return false;
+    }
+
+    return true;
+}
+
+}
diff --git a/tests/manual/hdr-qopenglwidget/openglprobeutils.h b/tests/manual/hdr-qopenglwidget/openglprobeutils.h
new file mode 100644
index 00000000..3b2f1ec3
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/openglprobeutils.h
@@ -0,0 +1,42 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef OPENGLPROBEUTILS_H
+#define OPENGLPROBEUTILS_H
+
+#include <QSurfaceFormat>
+
+namespace OpenGLProbeUtils
+{
+
+bool fuzzyCompareColorSpaces(const QSurfaceFormat::ColorSpace &lhs, const QSurfaceFormat::ColorSpace &rhs);
+bool probeFormat(const QSurfaceFormat &format, bool adjustGlobalState);
+
+};
+
+#endif // OPENGLPROBEUTILS_H
diff --git a/tests/manual/hdr-qopenglwidget/window.cpp b/tests/manual/hdr-qopenglwidget/window.cpp
new file mode 100644
index 00000000..5729660a
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/window.cpp
@@ -0,0 +1,219 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "window.h"
+
+#include "KisGLImageWidget.h"
+#include "KisGLImageF16.h"
+
+#include <cmath>
+
+#include <QMenu>
+#include <QMenuBar>
+#include <QToolBar>
+#include <QAction>
+#include <QDebug>
+
+#include <QVBoxLayout>
+#include <QHBoxLayout>
+#include <QLabel>
+
+#include <cmath>
+
+
+Window::Window()
+{
+    setWindowTitle("16 bit float QOpenGLWidget test");
+    QMenu *menu = menuBar()->addMenu("File");
+    QToolBar *tb = addToolBar("File");
+
+    m_quitAction = new QAction("Quit", this);
+    connect(m_quitAction, SIGNAL(triggered(bool)), this, SLOT(close()));
+    menu->addAction(m_quitAction);
+    tb->addAction(m_quitAction);
+
+    QWidget *centralWidget = new QWidget(this);
+    QVBoxLayout *layout = new QVBoxLayout(centralWidget);
+
+    QHBoxLayout *hLayout = new QHBoxLayout(centralWidget);
+
+    m_imageWidget = new KisGLImageWidget(QSurfaceFormat::scRGBColorSpace, this);
+    m_imageWidget->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding);
+    hLayout->addWidget(m_imageWidget, 0, Qt::AlignLeft);
+
+    m_imageWidgetSdr = new KisGLImageWidget(QSurfaceFormat::scRGBColorSpace, this);
+    m_imageWidgetSdr->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding);
+    hLayout->addWidget(m_imageWidgetSdr, 0, Qt::AlignLeft);
+
+    QImage image(QSize(255,255), QImage::Format_ARGB32);
+    image.fill(Qt::red);
+
+    QLabel *label = new QLabel(this);
+    label->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding);
+    hLayout->addWidget(label, 0, Qt::AlignLeft);
+
+    m_imageWidget->loadImage(initializeImage(false));
+    m_imageWidgetSdr->loadImage(initializeImage(true));
+    label->setPixmap(QPixmap::fromImage(convertToQImage(m_imageWidget->image())));
+
+    layout->addLayout(hLayout);
+
+    m_lblContextInfo = new QLabel(this);
+    layout->addWidget(m_lblContextInfo);
+
+    QLabel *lblNotes = new QLabel(this);
+    lblNotes->setWordWrap(true);
+    lblNotes->setText("* In SDR display mode all three images should look exactly the same\n"
+                      "* In HDR display mode: image 1 should look brighter than the others "
+                      "(it is HDR), images 2 and 3 should have exactly the same brightness and look");
+
+    layout->addWidget(lblNotes);
+
+    centralWidget->setLayout(layout);
+    setCentralWidget(centralWidget);
+}
+
+inline qfloat16 floatToFloat16(float x) {
+    qfloat16 result;
+    qFloatToFloat16(&result, &x, 1);
+    return result;
+}
+
+inline float float16ToFloat(qfloat16 x) {
+    float result;
+    qFloatFromFloat16(&result, &x, 1);
+    return result;
+}
+
+
+KisGLImageF16 Window::initializeImage(bool cropRange) const
+{
+    const int size = 256;
+    KisGLImageF16 image(size, size);
+    image.clearPixels();
+    qfloat16 *pixelPtr = image.data();
+
+    for (int y = 0; y < size; y++) {
+        for (int x = 0; x < size; x++) {
+            qfloat16 *pxl = reinterpret_cast<qfloat16*>(pixelPtr);
+
+            float hdrRedValue = 25.0f * std::pow(float(x) / size, 5.0f);
+
+            if (cropRange) {
+                hdrRedValue = qMin(hdrRedValue, 1.0f);
+            }
+
+            pxl[0] = floatToFloat16(hdrRedValue);
+
+            if (y > size / 2) {
+                const float portion = (float(y) / size - 0.5f) * 2.0f;
+                const float value = qMin(1.0f, 0.2f + 1.8f * portion);
+
+                pxl[1] = floatToFloat16(value);
+                pxl[2] = floatToFloat16(value);
+            } else {
+                pxl[1] = floatToFloat16(0.2);
+                pxl[2] = floatToFloat16(0.2);
+            }
+
+            pxl[3] = floatToFloat16(1.0);
+
+            pixelPtr += 4;
+        }
+    }
+
+    return image;
+}
+
+inline float linearToSRGB(float value)
+{
+    if (value <= 0.0f) {
+        value = 0.0f;
+    } else if (value < 0.0031308f) {
+        value = value * 12.92f;
+    } else if (value < 1.0f) {
+        value = std::pow(value, 0.41666f) * 1.055f - 0.055f;
+    } else {
+        value = 1.0f;
+    }
+    return value;
+}
+
+QImage Window::convertToQImage(const KisGLImageF16 &image) const
+{
+    const QSize size = image.size();
+    const qfloat16 *pixelPtr = image.constData();
+
+    QImage qimage(size, QImage::Format_ARGB32);
+    quint8 *qimagePixelPtr = qimage.bits();
+
+
+    for (int y = 0; y < size.height(); y++) {
+        for (int x = 0; x < size.width(); x++) {
+            const qfloat16 *srcPxl = pixelPtr;
+            quint8 *dstPxl = qimagePixelPtr;
+
+            auto convertChannel = [] (qfloat16 x) {
+                float value = float16ToFloat(x);
+                return quint8(linearToSRGB(value) * 255.0f);
+            };
+
+            dstPxl[0] =  convertChannel(srcPxl[2]);
+            dstPxl[1] =  convertChannel(srcPxl[1]);
+            dstPxl[2] =  convertChannel(srcPxl[0]);
+            dstPxl[3] =  convertChannel(srcPxl[3]);
+
+            pixelPtr += 4;
+            qimagePixelPtr += 4;
+        }
+    }
+
+    return qimage;
+}
+
+void Window::updateSurfaceInfo()
+{
+    const QSurfaceFormat format = m_imageWidget->context()->format();
+
+    m_lblContextInfo->setText(
+        QString("renderer: %1\ncolorSpace: %2\n\n")
+                .arg(format.renderableType() == QSurfaceFormat::OpenGL ? "openGL" : "openGL ES")
+                .arg(format.colorSpace() == QSurfaceFormat::sRGBColorSpace ? "sRGB" :
+                     format.colorSpace() == QSurfaceFormat::scRGBColorSpace ? "scRGB" :
+                     format.colorSpace() == QSurfaceFormat::bt2020PQColorSpace ? "Bt. 2020 PQ" :
+                     "unknown"));
+}
+
+void Window::showEvent(QShowEvent *ev)
+{
+    QMainWindow::showEvent(ev);
+
+    if (m_lblContextInfo->text().isEmpty()) {
+        updateSurfaceInfo();
+    }
+}
diff --git a/tests/manual/hdr-qopenglwidget/window.h b/tests/manual/hdr-qopenglwidget/window.h
new file mode 100644
index 00000000..fd8e5c03
--- /dev/null
+++ b/tests/manual/hdr-qopenglwidget/window.h
@@ -0,0 +1,69 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef WINDOW_H
+#define WINDOW_H
+
+#include <QMainWindow>
+
+class QAction;
+
+class GLWidget;
+class KisGLImageWidget;
+class KisGLImageF16;
+class QLabel;
+
+class Window : public QMainWindow
+{
+    Q_OBJECT
+
+public:
+    Window();
+
+    void showEvent(QShowEvent *ev) override;
+
+public Q_SLOTS:
+
+
+private:
+    KisGLImageF16 initializeImage(bool cropRange) const;
+    QImage convertToQImage(const KisGLImageF16 &image) const;
+
+    void updateSurfaceInfo();
+
+private:
+    GLWidget *m_glWidget {0};
+    QAction *m_openAction {0};
+    QAction *m_quitAction {0};
+    KisGLImageWidget *m_imageWidget;
+    KisGLImageWidget *m_imageWidgetSdr;
+    QLabel *m_lblContextInfo;
+
+};
+
+#endif
diff --git a/tests/manual/manual.pro b/tests/manual/manual.pro
index ab00a5ef..b202ed04 100644
--- a/tests/manual/manual.pro
+++ b/tests/manual/manual.pro
@@ -59,7 +59,7 @@ qtabbar
 
 qtConfig(opengl) {
     SUBDIRS += qopengltextureblitter
-    qtConfig(egl): SUBDIRS += qopenglcontext
+    qtConfig(egl): SUBDIRS += qopenglcontext hdr-qopenglwidget
 }
 
 win32: SUBDIRS -= network_remote_stresstest network_stresstest
-- 
2.22.0.windows.1

From 47bda028a372144467a775c57e1269c6b1b1080d Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Thu, 6 Dec 2018 16:16:27 +0300
Subject: [PATCH 09/27] Fix notification of QDockWidget when it gets undocked

Before the patch the notification was emitted only when the docker
was attached to the panel or changed a position on it.

Change-Id: Id3ffbd2018a8e68844d174328dd1c4ceb7fa01d3
---
 src/widgets/widgets/qdockwidget.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/widgets/widgets/qdockwidget.cpp b/src/widgets/widgets/qdockwidget.cpp
index 6c871aae..19fc2d16 100644
--- a/src/widgets/widgets/qdockwidget.cpp
+++ b/src/widgets/widgets/qdockwidget.cpp
@@ -1171,6 +1171,8 @@ void QDockWidgetPrivate::setWindowState(bool floating, bool unplug, const QRect
             QMainWindowLayout *mwlayout = qt_mainwindow_layout_from_dock(q);
             if (mwlayout)
                 emit q->dockLocationChanged(mwlayout->dockWidgetArea(q));
+        } else {
+            emit q->dockLocationChanged(Qt::NoDockWidgetArea);
         }
     }
 
-- 
2.22.0.windows.1

